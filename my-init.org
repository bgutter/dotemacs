#+TITLE:  Brandon's Emacs Init
#+AUTHOR: Brandon Guttersohn
#+EMAIL:  bguttersohn@gmail.com

This is my emacs init file, written in org-babel.

* Required Packages
This section ensures that all required packages are loaded.

TODO: Replace all of this with =use-package=.

#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'load-path "~/.emacs.d/lisp/")
(add-to-list 'load-path "~/.emacs.d/elpa/")

(add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)

(package-initialize)
(setq package-enable-at-startup nil)

(defvar refreshed-packages nil)
(defun package-require (package)
  "Require package, install if needed."
   ; source: babcore
  (package-activate package '(0))
  (condition-case nil (require package)
    (progn
      (if (not refreshed-packages)
          (progn
            (package-refresh-contents)
            (setq refreshed-packages t))))
      (error (package-install package))))

(package-require 'revive)          ; restore buffers and windows from previous session
(package-require 'buffer-move)     ; swap buffers between adjacent windows
(package-require 'diff-hl)         ; show changes from last commit with edge highlighting
(package-require 'uniquify)        ; rename buffers of same name intelligently
(package-require 'undo-tree)       ; incredible undo/redo support
(package-require 'auto-complete)   ; neat autocompletion
(package-require 'framemove)       ; jump between frames and windows
(package-require 'fuzzy)           ; fuzzy completion
(package-require 'hi-lock)
(package-require 'button-lock)
(package-require 'bm)
(package-require 'yasnippet)
#+END_SRC

* Localization

Specify paths to basic utilities on Windows

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (progn
    (setq
      find-program        "\"C:/Program Files (x86)/Git/bin/find.exe\""
      grep-program        "\"C:/Program Files (x86)/Git/bin/grep.exe\""
      diff-program        "\"C:/Program Files (x86)/Git/bin/diff.exe\""
      diff-command        "\"C:/Program Files (x86)/Git/bin/diff.exe\""
      git-program         "\"C:/Program Files (x86)/Git/bin/git.exe\""
      ispell-program-name "\"C:/Program Files (x86)/Aspell/bin/aspell.exe\""
      scheme-program      "\"C:/Program Files (x86)/MIT-GNU Scheme/bin/mit-scheme.exe\""
      ctags-bin-name      "\"C:/Program Files (x86)/ctags/ctags.exe\"")
    (add-to-list 'exec-path "C:/cygwin64/bin")
    (add-to-list 'exec-path "C:/Program Files (x86)/Git/bin")
    (setenv "PATH" (concat "C:\\Program Files (x86)\\Git\\bin;" (getenv "PATH")))
    (setenv "CYGWIN" "nodosfilewarning"))) ;; I don't remember but this did, but I remember it being very frustrating
#+END_SRC

Special hacks for Windows

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (progn
    (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
    (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)))
#+END_SRC

* Utility
This section defines general purpose code snippets, which are used throughout the rest of the file.

#+BEGIN_SRC emacs-lisp
(defmacro recenter-on-jump (&rest body)
  "If, during the evaulation of body, point moves past the window's limits,
   in either direction, recenter the buffer in the window."
  `(let*
       ((last-pt (window-end))
        (first-pt (window-start)))
     ,@body
     (when (or (> (point) last-pt) (< (point) first-pt))
            (recenter))))

(defmacro retain-position-from-symbol-start (&rest body)
  "Any change of point in this macro body will be readjusted to retain
   the starting distance from the beginning of the current symbol. Most
   reasonable use is when jumping between occurrences of the same symbol."
  `(let*
       ((pos (point))
        (offset (save-excursion
                  (when (not (looking-at "\\_<"))
                    (search-backward-regexp "\\_<"))
                  (- pos (point)))))
     ,@body
     (when (not (looking-at "\\_<"))
       (search-backward-regexp "\\_<"))
     (right-char offset)))

(defun kill-current-buffer ()
  "kill the current buffer."
  (interactive)
  (kill-buffer (current-buffer))
  (previous-appropriate-buffer-if-hidden))

(defun delete-window-ex (&optional window)
  (interactive)
  (let*
      ((frame  (window-frame window)))
    (if (eq (length (window-list frame)) 1)
        (delete-frame frame)
      (delete-window window))))

(defun delete-window-and-buffer (&optional window-arg skip-window)
"Intelligent buffer/window closing. If the buffer is not displayed anywhere else, then
delete it along with the window. Defaults to current window. skip-window lets you skip
the actual window-deletion step, so that this can be safely used in the frame-delete-functions
hook."
  (interactive)
  (message "Closing window...")
  (let*
      ((window (or window-arg (get-buffer-window)))
       (buffer (window-buffer window)))
    (if (and (= 1 (length (get-buffer-window-list buffer nil t)))
             (buffer-file-name buffer)
             (not (buffer-modified-p buffer)));; if we're the only window showing the buffer, and it is an unmodified file, kill it
        (progn
          (message (concat "Killing buffer " (buffer-name buffer)))
          (kill-buffer buffer)
          ;;(previous-appropriate-buffer-if-hidden))
          ))
    (unless skip-window
      (delete-window-ex window))))

(defun strip-text-properties(txt)
  (set-text-properties 0 (length txt) nil txt)
      txt)

(defmacro do-with-silent-bell (&rest body)
  `(let
       ((ring-bell-function-backup ring-bell-function))
     (setq ring-bell-function nil)
     ,@body
     (setq ring-bell-function ring-bell-function-backup)))

(defun m-keyboard-escape-quit ()
  (interactive)
  (do-with-silent-bell
   (keyboard-escape-quit)))

(defun custom-save-buffer ()
  "Save file, update diff-hl highlighting"
  (interactive)
  (when (or (and (boundp 'diff-hl-mode) diff-hl-mode) (and (boundp 'diff-hl-amend-mode) diff-hl-amend-mode))
    (diff-hl-update))
  (save-buffer))

(defun line-word-char-count (&optional start end)
   "Prints number of lines, words and characters in region or whole buffer."
   (interactive)
   (let ((n 0)
         (start (if mark-active (region-beginning) (point-min)))
         (end (if mark-active (region-end) (point-max))))
     (save-excursion
       (goto-char start)
       (while (< (point) end) (if (forward-word 1) (setq n (1+ n)))))
     (format "[ L%d W%d C%d ] " (count-lines start end) n (- end start))))

(defun line-to-top-of-window ()
   "Shift current line to the top of the window-  i.e. zt in Vim"
   (interactive)
   (set-window-start (selected-window) (point)))

(defun purge-buffers ()
  (interactive)
  (mapcar 'kill-buffer (remove-if '(lambda (x) (with-current-buffer x (get-buffer-window))) (buffer-list))))

(defun save-config-die ()
  (interactive)
  (save-current-configuration)
  (save-buffers-kill-terminal))

(defun opacity (value)
   "Sets the opacity of the frame window. 0=transparent/100=opaque"
   (interactive "nOpacity Value 0 - 100 opaque:")
   (set-frame-parameter (selected-frame) 'alpha value))
#+END_SRC

** Minor Modes

*** Sticky Buffer Mode

Marries a buffer to a window.

#+BEGIN_SRC emacs-lisp
(define-minor-mode sticky-buffer-mode
  "Make the current window always display this buffer."
  nil " sticky" nil
  (set-window-dedicated-p (selected-window) sticky-buffer-mode))
#+END_SRC

** Buffer Monitoring

This is a purely TODO item. Previous version had some code to monitor a buffer and alert upon new appearances of a particular regex.

* User Interface Settings
This section defines code which modifies how emacs displays buffers and interacts with the user.

** Tweaks

Show whitespace

#+BEGIN_SRC emacs-lisp
(global-whitespace-mode 0)
(setq whitespace-style '(face trailing))
#+END_SRC

Use visual bell instead of audible.

#+BEGIN_SRC emacs-lisp
;; nice little alternative visual bell; Miles Bader <miles /at/ gnu.org>
(defcustom echo-area-bell-string "*DING* "
  "Message displayed in mode-line by `echo-area-bell' function."
  :group 'user)

(defcustom echo-area-bell-delay 0.1
  "Number of seconds `echo-area-bell' displays its message."
  :group 'user)
;; internal variables

(defvar echo-area-bell-cached-string nil)

(defvar echo-area-bell-propertized-string nil)

(defun echo-area-bell ()
  "Briefly display a highlighted message in the echo-area.
    The string displayed is the value of `echo-area-bell-string',
    with a red background; the background highlighting extends to the
    right margin.  The string is displayed for `echo-area-bell-delay'
    seconds.
    This function is intended to be used as a value of `ring-bell-function'."
  (unless (memq this-command '(keyboard-quit keyboard-escape-quit))
    (unless (equal echo-area-bell-string echo-area-bell-cached-string)
      (setq echo-area-bell-propertized-string
            (propertize
             (concat
              (propertize
               "x"
               'display
               `(space :align-to (- right ,(+ 2 (length echo-area-bell-string)))))
              echo-area-bell-string)
             'face '(:background "red" :foreground "white" :weight bold)))
      (setq echo-area-bell-cached-string echo-area-bell-string))
    (message echo-area-bell-propertized-string)
    (sit-for echo-area-bell-delay)
    (message "")))
(setq ring-bell-function 'echo-area-bell)
#+END_SRC

Get ride of blinking cursor

#+BEGIN_SRC emacs-lisp
(setq default-cursor-type 'box)
(blink-cursor-mode -1)
#+END_SRC

Display trailing whitespace

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
#+END_SRC

Highlight body of parens

#+BEGIN_SRC emacs-lisp
(setq show-paren-style 'expression)
(show-paren-mode 1)
#+END_SRC

Use a consistent window name. This helps with AutoHotkey recognition on Windows, in addition to being a little more usable in Linux.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "emacs")
#+END_SRC

Make sure we push any kill-ring data into OS clipboard.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

When buffer is not modified in emacs, automatically reload it when its file changes on disk.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC

Tweak the text shown when hiding regions of a buffer.

#+BEGIN_SRC emacs-lisp
(setq hide-region-before-string "hidden-region-->")
(setq hide-region-after-string "<--hidden-region")
#+END_SRC

Make sure that diff-hl-mode is showing changes between now and the last commit, only.

#+BEGIN_SRC emacs-lisp
(global-diff-hl-amend-mode 1)
#+END_SRC

Set frame to 95% opacity, because I'm easily amused.

#+BEGIN_SRC emacs-lisp
(setq default-opacity 95)
(opacity default-opacity)
(add-to-list 'default-frame-alist `(alpha  . ,default-opacity))
#+END_SRC

Fall back to frame-moving if window-moving doesn't cut it.

#+BEGIN_SRC emacs-lisp
(setq framemove-hook-into-windmove t)
#+END_SRC

Remove flashy splash stuff

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-screen t)
(setq inhibit-startup-message t)
#+END_SRC

Show prefix keys in the echo area much faster.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.001)
#+END_SRC

Tabs are not okay.

#+BEGIN_SRC emacs-lisp
(add-hook 'font-lock-mode-hook
  (lambda ()
    (font-lock-add-keywords
      nil
      '(("\t" 0 'trailing-whitespace prepend)))))
#+END_SRC

Highlight some common tags.

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords nil
  '(("\\<\\(DEBUG\\)" 1 font-lock-warning-face prepend)
    ("\\<\\(FIXME\\)" 1 font-lock-warning-face prepend)
    ("\\<\\(TODO\\)"  1 font-lock-warning-face prepend)
    ("\\<\\(JIRA\\)"  1 font-lock-warning-face prepend)))
#+END_SRC

Clear the minibuffer.

#+BEGIN_SRC emacs-lisp
(delete-minibuffer-contents)
#+END_SRC

** Mode Line & Header Line

This code adds a strongly customized header and mode line.

#+BEGIN_SRC emacs-lisp
(defmacro my-header-line ()
  `(list
    '(:eval
      (when (and (projectile-project-p) (buffer-file-name))
        (let*
            ((mface  (if (window-has-focus)
                         'mode-line-buffer-name-face
                       'mode-line-buffer-name-inactive-face)))
          (propertize (if (and (projectile-project-p) (buffer-file-name))
                          (concat " " (car (last (split-string (projectile-project-root) "/") 2)) ": ")
                        " ") 'face mface))))

      '(:eval
        (let*
            ((mface (if (window-has-focus)
                        'my-header-line-face
                      'my-header-line-inactive-face)))
          (propertize
           (concat
            " "
            (if (buffer-file-name)
                (buffer-file-name)
              (buffer-name))
            (mode-line-fill mface (if (window-has-focus)
                                      0;34
                                    0)))
           'face mface)))))

(setq-default header-line-format (my-header-line))
(setq header-line-format (my-header-line))


(defvar my-selected-window nil)
(add-hook 'post-command-hook
          (lambda ()
            ;; (when (not (minibuffer-selected-window))
              (setq my-selected-window (selected-window))))

(defun window-has-focus ()
  (eq
   (selected-window)
   my-selected-window))

(defun debug-window-focus ()
  (interactive)
  (format "%s & %s & %s & %s & %s" mode-line-frame-identification (frame-selected-window) (get-buffer-window) (selected-frame) (window-frame (get-buffer-window))))

(defmacro mode-line-notification-entry (check text help-echo)
  `'(:eval (when ,check
             (let*
                 ((mface (if (window-has-focus)
                             'mode-line-notification-face
                           'mode-line-notification-inactive-face))
                  (bface (if (window-has-focus)
                             'my-header-line-face
                           'my-header-line-inactive-face)))
               (concat
                (propertize ,text
                           'face mface
                           'help-echo ,help-echo)
                (propertize " "
                            'face bface))))))

(defmacro mode-line-status-entry (check text help-echo)
  `'(:eval (when ,check
             (let*
                  ((mface (if (window-has-focus)
                              'mode-line-buffer-name-face
                            'mode-line-buffer-name-inactive-face))
                   (bface (if (window-has-focus)
                             'my-header-line-face
                           'my-header-line-inactive-face)))
             (concat
                (propertize ,text
                            'face mface
                            'help-echo ,help-echo)
                (propertize " "
                            'face bface))))))

(defmacro mode-line-buffer-name-entry (format-str help-echo)
  `'(:eval
     (let*
         ((mface (if (window-has-focus)
                     'mode-line-buffer-name-face
                   'mode-line-buffer-name-inactive-face)))
        (propertize ,format-str
                    'face mface
                    'help-echo ,help-echo))))

(defmacro mode-line-str-dflt (body)
  `'(:eval
      (let*
         ((mface (if (window-has-focus)
                     'my-header-line-face
                   'my-header-line-inactive-face)))
       (propertize
        ,body
        'face mface))))

(defun mode-line-fill (face reserve)
  "Return empty space using FACE and leaving RESERVE space on the right."
  (unless reserve
    (setq reserve 20))
  (when (and window-system (eq 'right (get-scroll-bar-mode)))
    (setq reserve (- reserve 3)))
  (propertize " "
              'display `((space :align-to (- (+ right right-fringe right-margin) ,reserve)))
              'face face))

(setq-default mode-line-format
  (list

    ;; ; time field
    ;; '(:eval
    ;;   (propertize (format-time-string " %I:%M%p ")
    ;;     'face 'mode-line-time-face
    ;;     'help-echo
    ;;     (concat (format-time-string "%c; ")
    ;;        (emacs-uptime "Uptime:%hh"))))

    ; buffer name field
    '(:eval
      (let*
          ((mface  (if (window-has-focus)
                              'mode-line-buffer-name-face
                            'mode-line-buffer-name-inactive-face)))
        (propertize " %b " 'face mface)))

    ; buffer position field
    (mode-line-str-dflt " %p (%l,%c) ")

    ; major mode field
    (mode-line-buffer-name-entry " %m " buffer-file-coding-system)

    (mode-line-str-dflt " ")

    ;;; MODE SPECIFIC AREAS

    ; text mode: Show word, letter, char count
    '(:eval (when (eq major-mode 'text-mode)
             (mode-line-str-dflt
              (if transient-mark-mode
               (line-word-char-count (point) (mark))
               (line-word-char-count)))))

    ;;; STATUSES: less important stuff
    (mode-line-status-entry (/= text-scale-mode-amount 0) (format " Â±%d " text-scale-mode-amount) "Font scale")
    (mode-line-status-entry buffer-read-only              " RO "                                  "Buffer is read-only")
    (mode-line-status-entry vc-mode                       (concat " VC:" vc-mode " ")             vc-mode)
    (mode-line-status-entry isearch-mode                  (concat " search: " isearch-string " ") "isearch in progress")

    ;;; NOTIFICATIONS: IMPORTANT STUFF
    (mode-line-notification-entry (and (buffer-modified-p) (buffer-file-name)) " !! "   "Buffer has been modified")
    (mode-line-notification-entry (buffer-narrowed-p)                          " >< "   "Buffer is narrowed")
    
    ;; '(:eval (debug-window-focus))
    ;; '(:eval mode-line-frame-identification)

    (mode-line-str-dflt
     (let*
         ((gap (if (window-has-focus)
                 8
                 0)))
       (mode-line-fill mface gap)))

    '(:eval
     (when (window-has-focus)
       (mode-line-buffer-name-entry (format-time-string " %I:%M%p ") "")))))

#+END_SRC

** Phrase Highlight

This highlights all occurrences of the thing at point, automatically.

#+BEGIN_SRC emacs-lisp
(add-hook 'pre-command-hook 'clear-phrase-highlight)
(defvar-local hlight-region-face-var nil)
(defvar-local hlight-regex nil)
(defvar-local hlight-region-type nil)
(defvar-local hlight-region-active nil)
(defvar-local region-occurrence-highlight-mode nil)
(defvar-local region-occurrence-highlight-at-point t)
(setq-default region-occurrence-highlight-at-point t)

(defun clear-phrase-highlight ()
  "Remove region phrase highlight"
  (if hlight-region-active
      (progn
        (unhighlight-regexp (hi-lock-process-phrase hlight-regex))
        (setq hlight-region-active nil)
        (font-lock-fontify-buffer))))

(defun update-phrase-highlight ()
  "Highlight region if active"
  (clear-phrase-highlight)
  (if (and region-occurrence-highlight-mode (not isearch-mode) (not (minibufferp)))
      (progn
        (setq hlight-regex nil)
        (if mark-active
            (setq
             hlight-regex           (buffer-substring-no-properties (region-beginning) (region-end))
             hlight-region-face-var 'region-occurrence-highlight-face
             hlight-region-type     'region)
          (let
              ((sym (thing-at-point 'symbol)))
            (if (and region-occurrence-highlight-at-point sym (> (length sym) 0))
                (setq hlight-regex           (concat "\\_<" (hi-lock-process-phrase (strip-text-properties (thing-at-point 'symbol))) "\\_>")
                      hlight-region-face-var 'region-occurrence-no-region-highlight-face
                      hlight-region-type     'at-pt))))
        (if hlight-regex
            (progn
              ;; (message (format "Occurrences of %s" hlight-regex))
              (highlight-phrase (hi-lock-process-phrase hlight-regex) hlight-region-face-var)
              (setq hlight-region-active t)
              (font-lock-fontify-buffer))))))

(run-with-idle-timer 0.25 t 'update-phrase-highlight)
#+END_SRC

* Key-bindings
Most of my custom key-bindings use the hyper key. The goal here is to prevent any reasonable possibility of collision between personal keybindings and package keybindings. By convention, C-<key> is already reserved for the user, but we have another modifier available anyway, so why not use it? In my case, the hyper modifier is bound to caps lock.

To map caps lock to hyper under Xorg, you may do the following:

#+BEGIN_SRC bash
clear mod4
keycode 66 = Hyper_L
add mod4 = Super_L Super_R
clear lock
add mod3 = Hyper_L
#+END_SRC

In windows, install AutoHotkey, and place the following in a startup script...

#+BEGIN_SRC autohotkey
SetTitleMatchMode, 2
IfWinActive, emacs
{
    CapsLock::AppsKey
    return
}
#+END_SRC

...with the following elisp...

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (setq w32-pass-lwindow-to-system nil
        w32-pass-rwindow-to-system nil
        w32-pass-apps-to-system nil
        w32-lwindow-modifier 'super
        w32-rwindow-modifier 'super
        w32-apps-modifier 'hyper))
#+END_SRC

Do note that this leaves the apps key unusable in emacs, except as a secondary hyper modifier. I have not yet found another way to do this which works well for me.

** Source Code Navigation

The following key-bindings provide more convenient ways to navigate source code.

*** Basic Navigation

Replace home with a "smart home".

#+BEGIN_SRC emacs-lisp
(defun smart-beginning-of-line ()
  "Move point to first non-whitespace character or beginning-of-line.
   Move point to the first non-whitespace character on this line.
   If point was already at that position, move point to beginning of line."
  (interactive) ; Use (interactive "^") in Emacs 23 to make shift-select work
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
         (beginning-of-line))))

(global-set-key (kbd "<home>") 'smart-beginning-of-line)
#+END_SRC

Forward/Backward Paragraph

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-<up>")   'backward-paragraph)
(global-set-key (kbd "M-<down>") 'forward-paragraph)
#+END_SRC

*** Search and Replace

Search current buffer for regular expression.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-a") 'isearch-forward-regexp)
#+END_SRC

Search and replace text in current buffer with regular expressions

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-r") 'query-replace-regexp)
#+END_SRC

*** Version Control

Jump to next and previous modified region of file, as determined by the current version control extension.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-[") (lambda() (interactive) (diff-hl-previous-hunk) (recenter)))
(global-set-key (kbd "H-]") (lambda() (interactive) (diff-hl-next-hunk)     (recenter)))
#+END_SRC

*** Next & Previous thing-at-point

Jump to next and previous instance of whatever is below the cursor. As a TODO, I'd like to make these behave a little better in org mode. Currently, they'll stop at matches in collapsed sections, and further jumping is not possible.

#+BEGIN_SRC emacs-lisp
(defun forward-thing-symbol ()
  (interactive)
  (update-phrase-highlight)
  (recenter-on-jump
   (if hlight-region-active
       (cond
        ((eq hlight-region-type 'at-pt) (retain-position-from-symbol-start
                                         (when (not (looking-at "\\_>"))
                                           (search-forward-regexp "\\_>"))
                                         (if (search-forward-regexp (concat "\\_<" (thing-at-point 'symbol) "\\_>") nil t nil)
                                             (message (format "Next instance of %s" (thing-at-point 'symbol)))
                                           (progn
                                             (ding)
                                             (message (format "No more instances of %s" (thing-at-point 'symbol)))))
                                         (search-backward-regexp "\\_<")))
        ((eq hlight-region-type 'region) (let*
                                             ((exchange (if (> (point) (mark)) t nil))
                                              (count    (if (> (point) (mark)) 1 2))
                                              (loc (save-excursion
                                                     (search-forward-regexp (hi-lock-process-phrase hlight-regex) nil t count))))
                                           (if loc
                                               (progn
                                                 (set-mark loc)
                                                 (goto-char loc)
                                                 (left-char (length hlight-regex))
                                                 (if exchange
                                                     (exchange-point-and-mark))
                                                 (message (format "Next instance of region content")))
                                             (progn
                                               (ding)
                                               (message (format "No more instances of region content"))))))))))

(defun backward-thing-symbol ()
  (interactive)
  (update-phrase-highlight)
  (recenter-on-jump
   (if hlight-region-active
       (cond
        ((eq hlight-region-type 'at-pt) (retain-position-from-symbol-start
                                         (if (search-backward-regexp (concat "\\_<" (thing-at-point 'symbol) "\\_>") nil t nil)
                                             (message (format "Previous instance of %s" (thing-at-point 'symbol)))
                                           (progn
                                             (ding)
                                             (message (format "First instance of %s" (thing-at-point 'symbol)))))))
        ((eq hlight-region-type 'region) (let*
                                             ((exchange (if (> (point) (mark)) nil t))
                                              (count    (if (> (point) (mark)) 2 1))
                                              (loc (save-excursion
                                                     (search-backward-regexp (hi-lock-process-phrase hlight-regex) nil t count))))
                                           (if loc
                                               (progn
                                                 (set-mark loc)
                                                 (goto-char (+ loc (length hlight-regex)))
                                                 (if exchange
                                                     (exchange-point-and-mark))
                                                 (message (format "Previous instance of region content")))
                                             (progn
                                               (ding)
                                               (message (format "First instance of region content"))))))))))

(global-set-key (kbd "<H-down>")   'forward-thing-symbol)
(global-set-key (kbd "<H-up>")     'backward-thing-symbol)
#+END_SRC

*** Next & Previous Symbol

Jump to the next or previous symbol.

#+BEGIN_SRC emacs-lisp
(defun backward-symbol (&optional arg)
 "Move backward until encountering the beginning of a symbol.
With argument, do this that many times."
 (interactive "p")
 (forward-symbol (- (or arg 1))))

(defun forward-symbol-beginning ()
  (interactive)
  (when (not (looking-at "\\_>"))
    (search-forward-regexp "\\_>"))
  (call-interactively 'forward-symbol)
  (search-backward-regexp "\\_<"))

(defun backward-symbol-beginning ()
  (interactive)
  (call-interactively 'backward-symbol))

(global-set-key (kbd "<H-left>")   'backward-symbol-beginning)
(global-set-key (kbd "<H-right>")  'forward-symbol-beginning)
#+END_SRC

*** Go To Line Number

Interactively prompt for line number, then jump to it.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-g") (lambda () (interactive) (call-interactively 'goto-line) (recenter)))
#+END_SRC

*** Bookmarking

Keys to toggle bookmark for current line, then jump between bookmarked lines in file.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-SPC")      'bm-toggle)
(global-set-key (kbd "H-S-SPC")    (lambda () (interactive) (let* ((bm-annotate-on-create t)) (bm-toggle))))
(global-set-key (kbd "H-}")        'bm-next)
(global-set-key (kbd "H-{")        'bm-previous)
(global-set-key (kbd "<left-margin> <mouse-1>") 'bm-toggle-mouse)
#+END_SRC

** Editing

Copy/paste with insert key, depending on whether region is active.

*This binding does not use hyper, and may cause collisions.*

#+BEGIN_SRC emacs-lisp
(defun smart-copy-paste ()
  "Smart copy or paste"
  (interactive)
  (if (use-region-p)
      (if (and (boundp 'rectangle-mark-mode) rectangle-mark-mode)
          (copy-rectangle-as-kill (region-beginning) (region-end))
        (kill-ring-save (region-beginning) (region-end)))
    (yank)))

(global-set-key (kbd "<insert>") 'smart-copy-paste)
#+END_SRC

Place cut behavior on the delete key when region is active.

*This binding does not use hyper, and may cause collisions.*

#+BEGIN_SRC emacs-lisp

(defun smart-cut-or-delete ()
  "If region, cut, else, delete char"
  (interactive)
  (if (use-region-p)
    (kill-region (region-beginning) (region-end))
    (delete-forward-char 1)))

(global-set-key (kbd "<delete>") 'smart-cut-or-delete)
#+END_SRC

Place undo/redo on the expected keys. Add a shortcut to show the undo history tree.

*Some of these bindings do not use hyper, and may cause collisions.*

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-z")   'undo-tree-undo)
(global-set-key (kbd "C-S-z") 'undo-tree-redo)
(global-set-key (kbd "H-z")   'undo-tree-visualize)
#+END_SRC

Add a "smart" delete key.

*This binding does not use hyper, and may cause collisions.*

#+BEGIN_SRC emacs-lisp
(defun whack-whitespace-after-point (arg)
  ;; https://www.emacswiki.org/emacs/DeletingWhitespace
  "Delete all white space from point to the next word.  With prefix ARG
  delete across newlines as well.  The only danger in this is that you
  don't have to actually be at the end of a word to make it work.  It
  skips over to the next whitespace and then whacks it all to the next
  word."
  ;; (interactive "P")
    (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
      (re-search-forward regexp nil t)
      (replace-match "" nil nil)))
(defun smart-batch-delete ()
  (interactive)
  (if (or (looking-at "$") (looking-at " "))
      (whack-whitespace-after-point t)
    (kill-word nil)))
(global-set-key (kbd "C-<delete>") 'smart-batch-delete)
#+END_SRC

Add a "smart" tab key. It indents at the start of a line, or when right of whitespace, but autocompletes elsewhere.

*This binding does not use hyper, and may cause collisions.*

#+BEGIN_SRC emacs-lisp
(defun smart-tab-key (indent autocomplete indent-count)
  "Indent when at left margin or right of whitespace, autocomplete elsewhere."
  (cond (( or (eq last-command 'yank) (eq last-command 'yank-pop)) (yank-pop))
        (( or
           (eq last-command 'find-tag)
           (eq last-command 'find-tag-other-window)
           (eq last-command 'find-tag-wrapped)
           (eq last-command 'find-tag-wrapped-new-window))
         (progn
           (let ((current-prefix-arg '(4)))
             (message "Finding next possible definition...")
             (call-interactively 'find-tag))
           (recenter-top-bottom)
           (setq this-command 'find-tag)))
        ((use-region-p) (indent-rigidly (region-beginning) (region-end) indent-count))
        ((or (= 0 (current-column)) (= ?\s (char-before))) (funcall indent))
        (t (funcall autocomplete))))

(defun generic-smart-tab-key ()
  "Indent when at left margin or right of whitespace, autocomplete elsewhere"
  (interactive)
  (smart-tab-key 'indent-for-tab-command 'ac-fuzzy-complete 1))

(add-hook 'prog-mode-hook
  '(lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "H-;")   'comment-or-uncomment-region-or-line)))
#+END_SRC

Add binding to insert snippets from yasnippet.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-y") 'yas-insert-snippet)
#+END_SRC

Insert new lines before/after the current line.

#+BEGIN_SRC emacs-lisp
(defun newline-after-current ()
  "Skip to end of this line, insert a new one, autoindent, recenter cursor."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent)
  (scroll-up 1))

(defun newline-before-current ()
  "Move this line down, go to beginning of a new line where this one was."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (move-beginning-of-line nil)
  (when (looking-at "[ \t]+$")
    (kill-line)
    (setq kill-ring (cdr kill-ring))
    (insert "\n")
    (forward-line -1))
  (forward-line -1)
  (indent-for-tab-command))

(global-set-key (kbd "C-<return>") 'newline-after-current)
(global-set-key (kbd "M-<return>") 'newline-before-current)
(global-set-key (kbd "C-M-<return>")  (lambda() (interactive) (newline-after-current)(newline-before-current)))
#+END_SRC

Correct indentation on a line.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-t") 'indent-according-to-mode)
#+END_SRC

** Buffer Operations

These bindings control buffer switching, naming, etc.

*** Navigation

Switch to buffer by name

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-b") 'switch-to-buffer)
#+END_SRC

Cycle through buffers (normal or hidden, depending on current buffer).

#+BEGIN_SRC emacs-lisp
(defun previous-appropriate-buffer-if-hidden ()
  (when (or
         (and (hidden-buffer-p) (not (dumping-window-p)))
         (and (not (hidden-buffer-p)) (dumping-window-p)))
    (previous-appropriate-buffer)))

(defun hidden-buffer-p ()
  (or
   (string-match "\*.*\*" (buffer-name))      ; *buffer*s
   (string-match "^COM[0-9]*$" (buffer-name)) ; windows serial buffer
   (string-match "^/dev/tty*" (buffer-name))  ; *nix serial buffer
   (string-match "^TAGS$" (buffer-name))))    ; TAGS file

(defun next-non-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-non-sys-buffer-with-basecase 'next-buffer start-buffer)))

(defun previous-non-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-non-sys-buffer-with-basecase 'previous-buffer start-buffer)))

(defun next-non-sys-buffer-with-basecase (advance-f base)
  (funcall advance-f)
  (if (and
       (not (eq base (buffer-name)))
       (hidden-buffer-p))
      (next-non-sys-buffer-with-basecase advance-f base)))

(defun next-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-sys-buffer-with-basecase 'next-buffer start-buffer)))

(defun previous-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-sys-buffer-with-basecase 'previous-buffer start-buffer)))

(defun next-sys-buffer-with-basecase (advance-f base)
  (funcall advance-f)
  (if (and
       (not (eq base (buffer-name)))
       (not( hidden-buffer-p)))
      (next-sys-buffer-with-basecase advance-f base)))

(defun next-appropriate-buffer ()
  (interactive)
  ; (message (apply 'concat (mapcar (lambda (x) (format "%s -- " x)) (buffer-list))))
  (if (dumping-window-p)
      (next-sys-buffer)
    (next-non-sys-buffer)))

(defun previous-appropriate-buffer ()
  (interactive)
  (if (dumping-window-p)
      (previous-sys-buffer)
    (previous-non-sys-buffer)))

(global-set-key (kbd "<prior>") 'previous-appropriate-buffer)
(global-set-key (kbd "<next>")  'next-appropriate-buffer)
#+END_SRC

Swap buffers between windows.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c C-<up>")    'buf-move-up)
(global-set-key (kbd "C-c C-<down>")  'buf-move-down)
(global-set-key (kbd "C-c C-<right>") 'buf-move-right)
(global-set-key (kbd "C-c C-<left>")  'buf-move-left)
#+END_SRC

Manually scroll the buffer 15 lines vertically, or 5 laterally.

#+BEGIN_SRC emacs-lisp
(defun scroll-up-15-lines ()
  (interactive)
  (scroll-down 15)) ;invert axis

(defun scroll-down-15-lines ()
  (interactive)
  (scroll-up 15)) ;; invert axes

(global-set-key (kbd "C-<up>")    'scroll-up-15-lines)
(global-set-key (kbd "C-<down>")  'scroll-down-15-lines)
(global-set-key (kbd "C-<right>") '(lambda () "" (interactive) (scroll-left 5))) ; invert-axis
(global-set-key (kbd "C-<left>")  '(lambda () "" (interactive) (scroll-right 5))) ; invert-axis
#+END_SRC

The following keys autoscroll the buffer based on the point.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-u") 'line-to-top-of-window)
(global-set-key (kbd "H-j") 'recenter)
#+END_SRC

Select all text in the buffer.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c a") 'mark-whole-buffer)
#+END_SRC

** Window and Frame Operations

These bindings control the size, shape, position, and opacity of windows and frames.

*** Toggle Fullscreen Display

Toggles emacs between full-screen and windowed mode.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<H-f11>") 'toggle-frame-fullscreen)
#+END_SRC

*** Navigate Windows

Move between windows.

*These bindings do not use hyper, and may cause collisions!*

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "S-<right>") 'windmove-right)
(global-set-key (kbd "S-<left>")  'windmove-left)
(global-set-key (kbd "S-<down>")  'windmove-down)
(global-set-key (kbd "S-<up>")    'windmove-up)
#+END_SRC

*** Split Current Window

This code lets you split the current window vertically or horizontally, while remaining in either the top, bottom, left, or right window.

#+BEGIN_SRC emacs-lisp
;; Defined for parity with their opposites

(defun split-window-above ()
  "Split current window into top and bottom, with focus left in bottom."
  (interactive)
  (split-window-below)
  (windmove-down))

(defun split-window-left ()
  "Split current window into left and right, with focus left in right."
  (interactive)
  (split-window-right)
  (windmove-right))

(global-set-key (kbd "C-c <down>")  'split-window-above)
(global-set-key (kbd "C-c <up>")    'split-window-below)
(global-set-key (kbd "C-c <left>")  'split-window-right)
(global-set-key (kbd "C-c <right>") 'split-window-left)
#+END_SRC

*** Resize Current Window

*These bindings do not use hyper, and may cause collisions!*

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-<up>")      (lambda () (interactive) (enlarge-window 5)))
(global-set-key (kbd "C-S-<right>")   'enlarge-window-horizontally)
(global-set-key (kbd "C-S-<down>")    (lambda () (interactive) (shrink-window 5)))
(global-set-key (kbd "C-S-<left>")    'shrink-window-horizontally)
#+END_SRC

*** Change Frame Opacity
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-<prior>") 'decrement-opacity)
(global-set-key (kbd "H-<next>")  'increment-opacity)
(global-set-key (kbd "H-1")       '(lambda () "" (interactive) (opacity 10)))
(global-set-key (kbd "H-2")       '(lambda () "" (interactive) (opacity 20)))
(global-set-key (kbd "H-3")       '(lambda () "" (interactive) (opacity 30)))
(global-set-key (kbd "H-4")       '(lambda () "" (interactive) (opacity 40)))
(global-set-key (kbd "H-5")       '(lambda () "" (interactive) (opacity 50)))
(global-set-key (kbd "H-6")       '(lambda () "" (interactive) (opacity 60)))
(global-set-key (kbd "H-7")       '(lambda () "" (interactive) (opacity 70)))
(global-set-key (kbd "H-8")       '(lambda () "" (interactive) (opacity 80)))
(global-set-key (kbd "H-9")       '(lambda () "" (interactive) (opacity 90)))
(global-set-key (kbd "H-0")       '(lambda () "" (interactive) (opacity 100)))
#+END_SRC
** Filesystem Operations

These key-bindings are used for modifying or navigating the filesystem.

*** Searching

Search for a regular expression recursively in a directory tree, display results interactively in an emacs buffer.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-f") 'rgrep)
#+END_SRC

** Keyboard Macros

Allocate F1-F4 specifically for saving and executing keyboard macros.

#+BEGIN_SRC emacs-lisp
(defun auto-name-macro (name)
  (if defining-kbd-macro
      (progn
        (kmacro-end-or-call-macro nil)
        (fset
         (intern (format "mcr-%s" name))
         last-kbd-macro))
    (execute-kbd-macro
     (intern
      (format "mcr-%s" name)))))

(defun force-execute-auto-name-macro (name)
  (execute-kbd-macro
     (intern
      (format "mcr-%s" name))))

(global-set-key (kbd "H-*")        'kmacro-start-macro)
(global-set-key (kbd "<f1>")       (lambda () (interactive) (auto-name-macro "f1")))
(global-set-key (kbd "<f2>")       (lambda () (interactive) (auto-name-macro "f2")))
(global-set-key (kbd "<f3>")       (lambda () (interactive) (auto-name-macro "f3")))
(global-set-key (kbd "<f4>")       (lambda () (interactive) (auto-name-macro "f4")))
(global-set-key (kbd "C-<f1>")     (lambda () (interactive) (force-execute-auto-name-macro "f1")))
(global-set-key (kbd "C-<f2>")     (lambda () (interactive) (force-execute-auto-name-macro "f2")))
(global-set-key (kbd "C-<f3>")     (lambda () (interactive) (force-execute-auto-name-macro "f3")))
(global-set-key (kbd "C-<f4>")     (lambda () (interactive) (force-execute-auto-name-macro "f4")))
#+END_SRC

** Other Shortcuts

*** Controlling Emacs

Take a page from Vim's notebook at use the escape key as a command toggle & mode exiting switch.

#+BEGIN_SRC emacs-lisp
(defun execute-command-toggle (prefixes)
  "If region active, clear it. Else, toggle the M-x menu."
  (interactive "P")
  (cond
    ((window-minibuffer-p)                    (m-keyboard-escape-quit))
    (mark-active                              (progn (setq mark-active nil) (run-hooks 'deactivate-mark-hook)))
    (t                                        (execute-extended-command prefixes))))

(defun execute-command-toggle-ignore-region (prefixes)
  "Toggle M-x menu."
  (interactive "P")
  (if (window-minibuffer-p)
      (m-keyboard-escape-quit)
    (execute-extended-command prefixes)))

(global-set-key (kbd "<escape>")   'execute-command-toggle)
(global-set-key (kbd "S-<escape>") 'execute-command-toggle-ignore-region)
#+END_SRC

*** Common Operations (F5-F8)

Set open-file, save-file, save-file-as, and close-file -like functions to function keys F5-F8.

*These bindings do not use the hyper modifier, and may case collisions!*

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>")   'find-file)
(global-set-key (kbd "<f6>")   'custom-save-buffer)
(global-set-key (kbd "<f7>")   'write-file)
(global-set-key (kbd "<S-f8>") 'delete-window-ex)
(global-set-key (kbd "<H-f8>") 'kill-current-buffer)
(global-set-key (kbd "<f8>")   'delete-window-and-buffer)
#+END_SRC

*** Special Modes (F9-F12)

Give shell and magit dedicated keys.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f9>") 'shell)
(global-set-key (kbd "<f10>") 'magit-status)
(global-set-key (kbd "<f11>") 'magit-blame)
;; f12 saved for recompilation in prog-mode and code evaluation in org-mode
#+END_SRC

*** Corrections

Shortcut for flyspell autocorrect.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-c") 'flyspell-auto-correct-word)
#+END_SRC

*** Adjust Text Scale

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-=") '(lambda () (interactive) (text-scale-increase 1)))
(global-set-key (kbd "H--") '(lambda () (interactive) (text-scale-decrease 1)))
#+END_SRC

** Mode-Specific Key-Bindings

Key bindings that apply only in certain contexts.

*** isearch-mode

*These bindings do not use hyper, and may cause collisions!*

#+BEGIN_SRC emacs-lisp
(define-key isearch-mode-map (kbd "<backspace>") 'isearch-del-char)
(define-key isearch-mode-map (kbd "<escape>")    'isearch-exit)
(define-key isearch-mode-map (kbd "<C-escape>")  'isearch-abort)
(define-key isearch-mode-map (kbd "<return>")    'isearch-repeat-forward)
(define-key isearch-mode-map (kbd "S-<return>")  'isearch-repeat-backward)
(define-key isearch-mode-map (kbd "<right>")     'isearch-yank-word-or-char)
(define-key isearch-mode-map (kbd "<left>")      'isearch-del-char)
(define-key isearch-mode-map (kbd "<down>")      'isearch-repeat-forward)
(define-key isearch-mode-map (kbd "<up>")        'isearch-repeat-backward)
#+END_SRC

*** query-replace

*These bindings do not use hyper, and may cause collisions!*

#+BEGIN_SRC emacs-lisp
(define-key query-replace-map (kbd "<up>")     'backup)
(define-key query-replace-map (kbd "<down>")   'skip)
(define-key query-replace-map (kbd "<escape>") 'exit)
(define-key query-replace-map (kbd "<return>") 'act)
(define-key query-replace-map (kbd "<insert>") 'edit)
#+END_SRC

*** c-mode

These are applied later in the c-mode-hook

#+BEGIN_SRC emacs-lisp
(defun c-smart-tab-key ()
  "Indent when at left margin or right of whitespace, autocomplete elsewhere"
  (interactive)
  (smart-tab-key 'c-indent-line-or-region 'dabbrev-expand c-basic-offset))

;; TODO: Wrote these long ago, should probably move to yasnippet.
(define-prefix-command 'c-shortcut-map)
(define-key c-shortcut-map (kbd "1") 'c-insert-region-heading)
(define-key c-shortcut-map (kbd "2") 'c-insert-function-skeleton)
(define-key c-shortcut-map (kbd "3") 'c-insert-forced-todo)
(define-key c-shortcut-map (kbd "4") 'c-insert-debugging-printf)
(define-key c-shortcut-map (kbd "5") 'c-insert-ternary-for-boolean-to-string)
(define-key c-shortcut-map (kbd "6") 'c-insert-todo-comment)
(define-key c-shortcut-map (kbd "f") 'c-insert-if-block)
(define-key c-shortcut-map (kbd "o") 'c-insert-for-block)
(define-key c-shortcut-map (kbd "w") 'c-insert-while-block)
(define-key c-shortcut-map (kbd "d") 'c-insert-do-while-block)
(define-key c-shortcut-map (kbd "F") 'c-insert-preproc-if-block)
(define-key c-shortcut-map (kbd "D") 'c-insert-preproc-ifdef-block)
(define-key c-shortcut-map (kbd "N") 'c-insert-preproc-ifndef-block)
(define-key c-shortcut-map (kbd "I") 'c-insert-preproc-include-block)

(defun c-insert-debugging-printf ()
  "Insert a debugging tag in C -- Garmin compatible."
  (interactive)
  (insert "printf(\"%50s:%d.\\n\", __FILE__, __LINE__ ); // TODO BJG: DEBUG!")
  (left-char 64))

(defun c-insert-todo-comment ()
  "Insert a todo tag (C-compliant)."
  (interactive)
  (insert " /* TODO BJG:  */ ")
  (left-char 4))

(defun c-insert-function-skeleton (name desc ret-type)
  "Insert the skeleton for a new function -- Garmin compatible."
  (interactive "sFunction Name: \nsDescription: \nsReturn Type: ")
  (insert "/*********************************************************************\n")
  (insert "*\n")
  (insert "*   PROCEDURE NAME:\n")
  (insert "*       ")
  (insert name)
  (insert "\n*\n")
  (insert "*   DESCRIPTION:\n")
  (insert "*       ")
  (insert desc)
  (insert "\n*\n")
  (insert "*********************************************************************/\n")
  (insert ret-type)
  (insert " ")
  (insert name)
  (insert "\n")
  (insert-c-basic-offset-spaces)
  (insert "(\n")
  (insert-c-basic-offset-spaces)
  (insert "\n")
  (insert-c-basic-offset-spaces)
  (insert ")\n")
  (insert "{\n\n} ")
  (insert "/* ")
  (insert name)
  (insert "() */")
  (left-char ( + 20 (length name))))

(defun c-insert-region-heading ()
  "Insert a region heading (variables, initializations, etc)."
  (interactive "")
  (insert "/*----------------------------------------------------------\n")
  (indent-for-tab-command)
  (insert "\n")
  (indent-for-tab-command)
  (insert "----------------------------------------------------------*/")
  (indent-for-tab-command)
  (beginning-of-line)
  (delete-char 2)
  (previous-line)
  (end-of-line)
  (backward-delete-char 2))

(defun c-insert-forced-todo ()
  ""
  (interactive)
  (insert "#error \"You forgot to come back to this, so you're not allowed to compile.\""))

(defun c-insert-if-block ()
  ""
  (interactive)
  (insert "if(  )")
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "}")
  (previous-line 3)
  (end-of-line)
  (left-char 2))

(defun c-insert-while-block ()
  ""
  (interactive)
  (insert "while(  )")
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "}")
  (previous-line 3)
  (end-of-line)
  (left-char 2))

(defun c-insert-for-block (var-name start-val end-val)
  ""
  (interactive "sIterator: \nsStart Val (inclusive): \nsEnd Val (Exclusive): ")
  (interactive)
  (insert (format "for( %s = %s; %s < %s; %s++ )" var-name start-val var-name end-val var-name))
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "}")
  (previous-line 1)
  (end-of-line)
  (indent-for-tab-command))

(defun c-insert-do-while-block ()
  ""
  (interactive)
  (insert "do")
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "} while(  );")
  (previous-line 1)
  (c-indent-line-or-region)
  (end-of-line))

(defun c-insert-preproc-if ()
  ""
  (interactive)
  (insert "#if(  )")
  (newline)
  (c-indent-line-or-region)
  (newline)
  (c-indent-line-or-region)
  (insert "#endif")
  (previous-line 2)
  (c-indent-line-or-region)
  (end-of-line)
  (left-char 2))

(add-hook 'c-mode-common-hook
  '(lambda ()
     (local-set-key (kbd "<tab>")   'c-smart-tab-key)
     (local-set-key (kbd "TAB")     'c-smart-tab-key)
     (local-set-key (kbd "C-t")     'c-indent-line-or-region)
     (local-set-key (kbd "C-r")     'align-current)
     (local-set-key (kbd "H-c")     'c-shortcut-map)))
#+END_SRC

* File Associations

** Quick Mappings
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.plt\\'" . gnuplot-mode))
(add-to-list 'auto-mode-alist '("\\.m$"     . octave-mode ))
#+END_SRC

** Generic Modes

B2C, T2C, and F2C files

#+BEGIN_SRC emacs-lisp
(define-generic-mode 
  '2c-mode                       ; name of the mode to create
  '("*")                         ; comments start with '!!'
  '("c_dep")                     ; keywords
  nil                            ; special words
  ;; '(("=" . 'font-lock-operator)     ;; '=' is an operator
  ;; (";" . 'font-lock-builtin))     ;; ';' is a built-in 
  '("\\.t2c\\'"  "\\.b2c\\'" "\\.f2c\\'")    ; files for which to activate this mode 
  '((lambda () (run-hooks 'prog-mode-hook)))                            ; other functions to call
  "A mode for B2C, T2C, & F2C files")   ; doc string for this mode
#+END_SRC

Monkey-C Mode

#+BEGIN_SRC emacs-lisp
(define-generic-mode
  'monkey-c-mode
  '("//")
  '("using" "as" "class" "extends" "function" "hidden" "return")
  '("initialize" "onUpdate")
  '("\\.mc\\'")
  '((lambda () (run-hooks 'prog-mode-hook)))
  "A mode for Monkey-C")
#+END_SRC

* Mode Management

Handle which modes/settings are triggered where.

** Global Default Modes

Hide the toolbar, menu bar, and scroll bars.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode   -1)
(menu-bar-mode    0)
(scroll-bar-mode -1)
#+END_SRC

Highlight and jump through instances of whatever is at point.

#+BEGIN_SRC emacs-lisp
(setq region-occurrence-highlight-mode t)
#+END_SRC

Ensure that org-mode start up using indentation.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
#+END_SRC

Use yasnippet everywhere.

#+BEGIN_SRC emacs-lisp
(yas-global-mode t)
#+END_SRC

Use ido by default.

#+BEGIN_SRC emacs-lisp
(ido-mode)
#+END_SRC

** Mode Triggers

*** prog-mode

The hook =prog-mode-hook= is triggered in all programming major-modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
  '(lambda ()
    (flyspell-prog-mode) ;; Spelling corrections in comments
    (linum-mode)))       ;; Needed to catch compiler errors when compiling outside of emacs
#+END_SRC

*** text-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
  (lambda ()
    (flyspell-mode)
    (visual-line-mode)
    (variable-pitch-mode t)
    (text-scale-increase 1)))
#+END_SRC

*** org-mode

Mode hooks

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
  (lambda ()
    (visual-line-mode)
    (variable-pitch-mode nil)
    (text-scale-increase 0)))
#+END_SRC

Adjust the keymap just a bit...

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "S-<right>")   'windmove-right)
(define-key org-mode-map (kbd "S-<left>")    'windmove-left)
(define-key org-mode-map (kbd "S-<down>")    'windmove-down)
(define-key org-mode-map (kbd "S-<up>")      'windmove-up)
(define-key org-mode-map (kbd "C-S-<up>")    (lambda () (interactive) (enlarge-window 5)))
(define-key org-mode-map (kbd "C-S-<right>") 'enlarge-window-horizontally)
(define-key org-mode-map (kbd "C-S-<down>")  (lambda () (interactive) (shrink-window 5)))
(define-key org-mode-map (kbd "C-S-<left>")  'shrink-window-horizontally)
(define-key org-mode-map (kbd "M-<up>")      'backward-paragraph)
(define-key org-mode-map (kbd "M-<down>")    'forward-paragraph)
#+END_SRC

*** c-mode

Use employer's preferred C format...

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
  '(lambda ()
     (set 'c-basic-offset  4)            ; 4 spaces for indentation
     (set 'c-electric-flag nil)          ; don't fuck with my indentation as I type
     (c-set-style "whitesmith")
     (setq comment-start "// ")
     (setq comment-end   "")))
#+END_SRC

*** octave-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'octave-mode-hook
  (lambda ()
    (local-set-key (kbd "C-\\") 'octave-send-region-or-line)))
#+END_SRC
*** compilation-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'compilation-mode-hook
  (lambda ()
    (visual-line-mode)
    (local-set-key (kbd "H-]") 'next-error)
    (local-set-key (kbd "H-[") 'previous-error)))
#+END_SRC
*** shell-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook
  (lambda ()
    (local-set-key (kbd "C-M-l") nil)
    (local-set-key (kbd "C-<up>") 'scroll-up-15-lines)
    (local-set-key (kbd "C-<down>") 'scroll-down-15-lines)
    (local-set-key (kbd "C-p") 'comint-previous-input)
    (local-set-key (kbd "C-n") 'comint-next-input)
    (setq show-trailing-whitespace nil)
    (visual-line-mode t)))
#+END_SRC
*** python-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>")         'generic-smart-tab-key)
    (local-set-key (kbd "TAB")           'generic-smart-tab-key)
    (local-set-key (kbd "C-t")           'indent-for-tab-command)
    (local-set-key (kbd "<backspace>")   'backward-delete-char-untabify)
    (local-set-key (kbd "C-\\")          'run-python-in-shell)
    (local-set-key (kbd "C-r")           'align-current)
    (local-set-key (kbd "C-|")           'python-shell-send-buffer)))
#+END_SRC
*** ruby-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'ruby-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t") 'indent-for-tab-command)))
#+END_SRC

*** scheme-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'scheme-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t")   'indent-for-tab-command)))
#+END_SRC

*** emacs-lisp-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t")   'indent-for-tab-command)))
#+END_SRC

*** term-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'term-mode-hook
  (lambda ()
    (linum-mode -1)
    (setq show-trailing-whitespace nil)
    (term-pager-toggle)))
#+END_SRC
* Package Configurations
** org-mode

Use minted for code.

#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted")
                                 ("margin=2cm" "geometry" nil))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

* Monkey Patching

** isearch Advice

This advice modifies isearch such that it will always auto-wrap whenever a match is not found between point and the end of the buffer.

#+BEGIN_SRC emacs-lisp
(defadvice isearch-search (after isearch-no-fail activate)
  "Autowrap searches."
  (unless isearch-success
    (ad-disable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)
    (isearch-repeat (if isearch-forward 'forward))
    (ad-enable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)))
#+END_SRC

This advice causes isearch, the split-window-*, compilation mode, etc, functions to recenter the buffer. This means less time spent searching for the cursor, without having a distracting cursor design.

#+BEGIN_SRC emacs-lisp
 (defadvice isearch-forward
    (after isearch-forward-recenter activate)
    (recenter))

(defadvice isearch-repeat-forward
  (after isearch-repeat-forward-recenter activate)
  (recenter))

(defadvice isearch-repeat-backward
  (after isearch-repeat-backward-recenter activate)
  (recenter))

(defadvice isearch-printing-char
  (after isearch-printing-char-then-recenter activate)
  (recenter))

(defadvice split-window-below
  (after split-window-below-recenter activate)
  (recenter))

(defadvice split-window-left
  (after split-window-left-recenter activate)
  (recenter))

(defadvice split-window-right
  (after split-window-right-recenter activate)
  (recenter))

(defadvice split-window-above
  (after split-window-above-recenter activate)
  (recenter))

(defadvice compile-goto-error
  (after compile-goto-error-then-recenter activate)
  (recenter))
#+END_SRC
** diff-hl Triggers

Whenever a file in version control is opened, enable diff-hl mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook
  (lambda ()
    (when (vc-backend (buffer-file-name))
        (diff-hl-mode)
        (diff-hl-update))))
#+END_SRC
