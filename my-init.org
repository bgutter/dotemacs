#+TITLE:  Brandon's Emacs Init
#+AUTHOR: Brandon Guttersohn
#+EMAIL:  bguttersohn@gmail.com

This is my emacs init file, written in org-babel.

* Localization (pre-package)

Set config variables on a per-system basis. TODO need a better approach.

#+BEGIN_SRC emacs-lisp
(cond
  ((eq device-name 'brandon-babypad-archlinux) ;; x230
     (progn
        (setq load-org t)
        ))
   ((eq device-name 'brandon-thinkpad-archlinux) ;; p51
     (progn
       (setq load-org t)
        ))
   (t
     (progn
       (setq load-org t)
       )))

(unless (boundp 'use-exwm)
  (setq use-exwm nil))
#+END_SRC

#+RESULTS:

* Required Packages
This section ensures that all required packages are loaded.

TODO: Replace all of this with =use-package=.

#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'load-path "~/.emacs.d/lisp/")
(add-to-list 'load-path "~/.emacs.d/elpa/")

(add-to-list 'package-archives
    '("melpa" . "http://melpa.milkbox.net/packages/") t)

(package-initialize)
(setq package-enable-at-startup nil)

(defvar refreshed-packages nil)
(defun package-require (package)
  "Require package, install if needed."
   ; source: babcore
  (package-activate package '(0))
  (condition-case nil (require package)
    (progn
      (if (not refreshed-packages)
          (progn
            (package-refresh-contents)
            (setq refreshed-packages t))))
      (error (package-install package))))

(package-require 'revive)           ; restore buffers and windows from previous session
(package-require 'buffer-move)      ; swap buffers between adjacent windows
(package-require 'diff-hl)          ; show changes from last commit with edge highlighting
(package-require 'uniquify)         ; rename buffers of same name intelligently
(package-require 'undo-tree)        ; incredible undo/redo support
(package-require 'auto-complete)    ; neat autocompletion
(package-require 'framemove)        ; jump between frames and windows
(package-require 'fuzzy)            ; fuzzy completion
(package-require 'hi-lock)          ; arbitrary text hilighting
(package-require 'button-lock)      ; face attribute that makes links from text
(package-require 'bm)               ; bookmark manager
(package-require 'yasnippet)        ; snippet pasting framework
(package-require 'anzu)             ; show total/current matches in isearch
(package-require 'helm)             ; awesome completions
(package-require 'shackle)          ; control window placement
(package-require 'visual-regexp)    ; visualize regular expressions in real-time
(package-require 'expand-region)    ; Expand region
(package-require 'eyebrowse)        ; Workspace management
(package-require 'origami)          ; awesome code folding
(package-require 'general)          ; sane key mapping architecture
(package-require 'which-key)        ; Display options after prefix keys are entered
(package-require 'helm-swoop)       ; Quick content based line navigation
(package-require 'ivy)              ; More friendly helm
(package-require 'swiper)           ; ivy's swoop
(package-require 'counsel)          ; ivy's (awesome) bloat
(package-require 'hy-mode)          ; Lisp on Python
(package-require 'org-autolist)     ; Automatically add bullets on return
#+END_SRC

* Localization (post-package)

Specify paths to basic utilities on Windows

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (progn
    (setq
      find-program        "\"C:/Program Files (x86)/Git/bin/find.exe\""
      grep-program        "\"C:/Program Files (x86)/Git/bin/grep.exe\""
      diff-program        "\"C:/Program Files (x86)/Git/bin/diff.exe\""
      diff-command        "\"C:/Program Files (x86)/Git/bin/diff.exe\""
      git-program         "\"C:/Program Files (x86)/Git/bin/git.exe\""
      ispell-program-name "\"C:/Program Files (x86)/Aspell/bin/aspell.exe\""
      scheme-program      "\"C:/Program Files (x86)/MIT-GNU Scheme/bin/mit-scheme.exe\""
      ctags-bin-name      "\"C:/Program Files (x86)/ctags/ctags.exe\"")
    (add-to-list 'exec-path "C:/cygwin64/bin")
    (add-to-list 'exec-path "C:/Program Files (x86)/Git/bin")
    (setenv "PATH" (concat "C:\\Program Files (x86)\\Git\\bin;" (getenv "PATH")))
    (setenv "CYGWIN" "nodosfilewarning"))) ;; I don't remember but this did, but I remember it being very frustrating
#+END_SRC

Special hacks for Windows

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (progn
    (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
    (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)))
#+END_SRC

* Utility

This section defines general purpose code snippets, which are used throughout the rest of the file.

#+BEGIN_SRC emacs-lisp
(defun dumping-window-p ()
  "Hack, need to clean up.."
  nil)
(defun projectile-project-p ()
  "ditto"
  nil)

(defmacro recenter-on-jump (&rest body)
  "If, during the evaulation of body, point moves past the window's limits,
   in either direction, recenter the buffer in the window."
  `(let*
       ((last-pt (window-end))
        (first-pt (window-start)))
     ,@body
     (when (or (> (point) last-pt) (< (point) first-pt))
            (recenter))))

(defmacro retain-position-from-symbol-start (&rest body)
  "Any change of point in this macro body will be readjusted to retain
   the starting distance from the beginning of the current symbol. Most
   reasonable use is when jumping between occurrences of the same symbol."
  `(let*
       ((pos (point))
        (offset (save-excursion
                  (when (not (looking-at "\\_<"))
                    (search-backward-regexp "\\_<"))
                  (- pos (point)))))
     ,@body
     (when (not (looking-at "\\_<"))
       (search-backward-regexp "\\_<"))
     (right-char offset)))

(defun kill-current-buffer ()
  "kill the current buffer."
  (interactive)
  (kill-buffer (current-buffer))
  (previous-appropriate-buffer-if-hidden))

(defun delete-window-ex (&optional window)
  (interactive)
  (let*
      ((frame  (window-frame window)))
    (if (eq (length (window-list frame)) 1)
        (delete-frame frame)
      (delete-window window))))

(defun delete-window-and-buffer (&optional window-arg skip-window)
"Intelligent buffer/window closing. If the buffer is not displayed anywhere else, then
delete it along with the window. Defaults to current window. skip-window lets you skip
the actual window-deletion step, so that this can be safely used in the frame-delete-functions
hook."
  (interactive)
  (message "Closing window...")
  (let*
      ((window (or window-arg (get-buffer-window)))
       (buffer (window-buffer window)))
    (if (and (= 1 (length (get-buffer-window-list buffer nil t)))
             (buffer-file-name buffer)
             (not (buffer-modified-p buffer)));; if we're the only0 window showing the buffer, and it is an unmodified file, kill it
        (progn
          (message (concat "Killing buffer " (buffer-name buffer)))
          (kill-buffer buffer)
          ;;(previous-appropriate-buffer-if-hidden))
          ))
    (unless skip-window
      (delete-window-ex window))))

(defun strip-text-properties(txt)
  (set-text-properties 0 (length txt) nil txt)
      txt)

(defmacro do-with-silent-bell (&rest body)
  `(let
       ((ring-bell-function-backup ring-bell-function))
     (setq ring-bell-function nil)
     ,@body
     (setq ring-bell-function ring-bell-function-backup)))

(defun m-keyboard-escape-quit ()
  (interactive)
  (do-with-silent-bell
   (keyboard-escape-quit)))

(defun custom-save-buffer ()
  "Save file, update diff-hl highlighting"
  (interactive)
  (when (or (and (boundp 'diff-hl-mode) diff-hl-mode) (and (boundp 'diff-hl-amend-mode) diff-hl-amend-mode))
    (diff-hl-update))
  (save-buffer))

(defun line-word-char-count (&optional start end)
   "Prints number of lines, words and characters in region or whole buffer."
   (interactive)
   (let ((n 0)
         (start (if mark-active (region-beginning) (point-min)))
         (end (if mark-active (region-end) (point-max))))
     (save-excursion
       (goto-char start)
       (while (< (point) end) (if (forward-word 1) (setq n (1+ n)))))
     (format "[ L%d W%d C%d ] " (count-lines start end) n (- end start))))

(defun line-to-top-of-window ()
   "Shift current line to the top of the window-  i.e. zt in Vim"
   (interactive)
   (set-window-start (selected-window) (point)))

(defun purge-buffers ()
  (interactive)
  (mapcar 'kill-buffer (remove-if '(lambda (x) (with-current-buffer x (get-buffer-window))) (buffer-list))))

(defun save-config-die ()
  (interactive)
  (save-current-configuration)
  (save-buffers-kill-terminal))

(defun opacity (value)
   "Sets the opacity of the frame window. 0=transparent/100=opaque"
   (interactive "nOpacity Value 0 - 100 opaque:")
   (set-frame-parameter (selected-frame) 'alpha value))
#+END_SRC

#+RESULTS:
: opacity

** Minor Modes

*** Sticky Buffer Mode

Marries a buffer to a window.

#+BEGIN_SRC emacs-lisp
(define-minor-mode sticky-buffer-mode
  "Make the current window always display this buffer."
  nil " sticky" nil
  (set-window-dedicated-p (selected-window) sticky-buffer-mode))
#+END_SRC

** Buffer Monitoring

This is a purely TODO item. Previous version had some code to monitor a buffer and alert upon new appearances of a particular regex.

** Package Extensions

Preload swiper with thing at point.

#+BEGIN_SRC emacs-lisp
;; https://github.com/abo-abo/swiper/issues/1068
(defun ivy-with-thing-at-point (cmd)
  (let ((ivy-initial-inputs-alist
         (list
          (cons cmd (thing-at-point 'symbol)))))
    (funcall cmd)))

;; Example 2
(defun swiper-thing-at-point ()
  (interactive)
  (ivy-with-thing-at-point 'swiper))
#+END_SRC

* User Interface Settings
This section defines code which modifies how emacs displays buffers and interacts with the user.

** Tweaks

DISABLED: Use fuzzy matching in ivy

#+BEGIN_SRC
(setq ivy-re-builders-alist
      '((t . ivy--regex-fuzzy)))
#+END_SRC

Allow file management in counsel's file-find

#+BEGIN_SRC emacs-lisp
;; https://github.com/abo-abo/swiper/wiki/Copy,-move-and-delete-file-actions-for-counsel-find-file
(defun reloading (cmd)
    (lambda (x)
      (funcall cmd x)
      (ivy--reset-state ivy-last)))
  (defun given-file (cmd prompt) ; needs lexical-binding
    (lambda (source)
      (let ((target
      (let ((enable-recursive-minibuffers t))
      (read-file-name
      (format "%s %s to:" prompt source)))))
      (funcall cmd source target 1))))
(defun confirm-delete-file (x)
    (dired-delete-file x 'confirm-each-subdirectory))

  (ivy-add-actions
   'counsel-find-file
   `(("c" ,(given-file #'copy-file "Copy") "copy")
     ("d" ,(reloading #'confirm-delete-file) "delete")
     ("m" ,(reloading (given-file #'rename-file "Move")) "move")))
  (ivy-add-actions
   'counsel-projectile-find-file
   `(("c" ,(given-file #'copy-file "Copy") "copy")
     ("d" ,(reloading #'confirm-delete-file) "delete")
     ("m" ,(reloading (given-file #'rename-file "Move")) "move")
     ("b" counsel-find-file-cd-bookmark-action "cd bookmark")))
#+END_SRC

#+RESULTS:
: .*\*helm.*\|.*\*Minibuf-.*

Show current/total matches in isearch

#+BEGIN_SRC emacs-lisp
(global-anzu-mode +1)
#+END_SRC

Show whitespace

#+BEGIN_SRC emacs-lisp
(global-whitespace-mode 0)
(setq whitespace-style '(face trailing))
#+END_SRC

Use visual bell instead of audible.

#+BEGIN_SRC emacs-lisp
;; nice little alternative visual bell; Miles Bader <miles /at/ gnu.org>
(defcustom echo-area-bell-string "*DING* "
  "Message displayed in mode-line by `echo-area-bell' function."
  :group 'user)

(defcustom echo-area-bell-delay 0.1
  "Number of seconds `echo-area-bell' displays its message."
  :group 'user)
;; internal variables

(defvar echo-area-bell-cached-string nil)

(defvar echo-area-bell-propertized-string nil)

(defun echo-area-bell ()
  "Briefly display a highlighted message in the echo-area.
    The string displayed is the value of `echo-area-bell-string',
    with a red background; the background highlighting extends to the
    right margin.  The string is displayed for `echo-area-bell-delay'
    seconds.
    This function is intended to be used as a value of `ring-bell-function'."
  (unless (memq this-command '(keyboard-quit keyboard-escape-quit))
    (unless (equal echo-area-bell-string echo-area-bell-cached-string)
      (setq echo-area-bell-propertized-string
            (propertize
             (concat
              (propertize
               "x"
               'display
               `(space :align-to (- right ,(+ 2 (length echo-area-bell-string)))))
              echo-area-bell-string)
             'face '(:background "red" :foreground "white" :weight bold)))
      (setq echo-area-bell-cached-string echo-area-bell-string))
    (message echo-area-bell-propertized-string)
    (sit-for echo-area-bell-delay)
    (message "")))
(setq ring-bell-function 'echo-area-bell)
#+END_SRC

Get rid of blinking cursor

#+BEGIN_SRC emacs-lisp
(setq default-cursor-type 'box)
(blink-cursor-mode -1)
#+END_SRC

Display trailing whitespace

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
#+END_SRC

Highlight body of parens

#+BEGIN_SRC emacs-lisp
(setq show-paren-style 'expression)
(show-paren-mode 1)
#+END_SRC

Use a consistent window name. This helps with AutoHotkey recognition on Windows, in addition to being a little more usable in Linux.

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "emacs")
#+END_SRC

Make sure we push any kill-ring data into OS clipboard.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

Highlight the current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

When buffer is not modified in emacs, automatically reload it when its file changes on disk.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC

Tweak the text shown when hiding regions of a buffer.

#+BEGIN_SRC emacs-lisp
(setq hide-region-before-string "hidden-region-->")
(setq hide-region-after-string "<--hidden-region")
#+END_SRC

Make sure that diff-hl-mode is showing changes between now and the last commit, only.

#+BEGIN_SRC emacs-lisp
(global-diff-hl-amend-mode 1)
#+END_SRC

Fall back to frame-moving if window-moving doesn't cut it.

#+BEGIN_SRC emacs-lisp
(setq framemove-hook-into-windmove t)
#+END_SRC

Remove flashy splash stuff

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-screen t)
(setq inhibit-startup-message t)
#+END_SRC

Show prefix keys in the echo area much faster.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.001)
#+END_SRC

Tabs are not okay.

#+BEGIN_SRC emacs-lisp
(add-hook 'font-lock-mode-hook
  (lambda ()
    (font-lock-add-keywords
      nil
      '(("\t" 0 'trailing-whitespace prepend)))))
#+END_SRC

Highlight some common tags.

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords nil
  '(("\\<\\(DEBUG\\)" 1 font-lock-warning-face prepend)
    ("\\<\\(FIXME\\)" 1 font-lock-warning-face prepend)
    ("\\<\\(TODO\\)"  1 font-lock-warning-face prepend)
    ("\\<\\(JIRA\\)"  1 font-lock-warning-face prepend)))
#+END_SRC

Clear the minibuffer.

#+BEGIN_SRC emacs-lisp
(delete-minibuffer-contents)
#+END_SRC

** Mode Line & Header Line

This code adds a strongly customized header and mode line.

#+BEGIN_SRC emacs-lisp
(defmacro my-header-line ()
  `(list
    '(:eval
      (when (and (projectile-project-p) (buffer-file-name))
        (let*
            ((mface  (if (window-has-focus)
                         'mode-line-buffer-name-face
                       'mode-line-buffer-name-inactive-face)))
          (propertize (if (and (projectile-project-p) (buffer-file-name))
                          (concat " " (car (last (split-string (projectile-project-root) "/") 2)) ": ")
                        " ") 'face mface))))

      '(:eval
        (let*
            ((mface (if (window-has-focus)
                        'my-header-line-face
                      'my-header-line-inactive-face)))
          (propertize
           (concat
            " "
            (if (buffer-file-name)
                (buffer-file-name)
              (buffer-name))
            (mode-line-fill mface (if (window-has-focus)
                                      0;34
                                    0)))
           'face mface)))))

(setq-default header-line-format (my-header-line))
(setq header-line-format (my-header-line))


(defvar my-selected-window nil)
(add-hook 'post-command-hook
          (lambda ()
            ;; (when (not (minibuffer-selected-window))
              (setq my-selected-window (selected-window))))

(defun window-has-focus ()
  (eq
   (selected-window)
   my-selected-window))

(defun debug-window-focus ()
  (interactive)
  (format "%s & %s & %s & %s & %s" mode-line-frame-identification (frame-selected-window) (get-buffer-window) (selected-frame) (window-frame (get-buffer-window))))

(defmacro mode-line-notification-entry (check text help-echo)
  `'(:eval (when ,check
             (let*
                 ((mface (if (window-has-focus)
                             'mode-line-notification-face
                           'mode-line-notification-inactive-face))
                  (bface (if (window-has-focus)
                             'my-header-line-face
                           'my-header-line-inactive-face)))
               (concat
                (propertize ,text
                           'face mface
                           'help-echo ,help-echo)
                (propertize " "
                            'face bface))))))

(defmacro mode-line-status-entry (check text help-echo)
  `'(:eval (when ,check
             (let*
                  ((mface (if (window-has-focus)
                              'mode-line-buffer-name-face
                            'mode-line-buffer-name-inactive-face))
                   (bface (if (window-has-focus)
                             'my-header-line-face
                           'my-header-line-inactive-face)))
             (concat
                (propertize ,text
                            'face mface
                            'help-echo ,help-echo)
                (propertize " "
                            'face bface))))))

(defmacro mode-line-buffer-name-entry (format-str help-echo)
  `'(:eval
     (let*
         ((mface (if (window-has-focus)
                     'mode-line-buffer-name-face
                   'mode-line-buffer-name-inactive-face)))
        (propertize ,format-str
                    'face mface
                    'help-echo ,help-echo))))

(defmacro mode-line-str-dflt (body)
  `'(:eval
      (let*
         ((mface (if (window-has-focus)
                     'my-header-line-face
                   'my-header-line-inactive-face)))
       (propertize
        ,body
        'face mface))))

(defun mode-line-fill (face reserve)
  "Return empty space using FACE and leaving RESERVE space on the right."
  (unless reserve
    (setq reserve 20))
  (when (and window-system (eq 'right (get-scroll-bar-mode)))
    (setq reserve (- reserve 3)))
  (propertize " "
              'display `((space :align-to (- (+ right right-fringe right-margin) ,reserve)))
              'face face))

(setq-default mode-line-format
  (list

    ;; ; time field
    ;; '(:eval
    ;;   (propertize (format-time-string " %I:%M%p ")
    ;;     'face 'mode-line-time-face
    ;;     'help-echo
    ;;     (concat (format-time-string "%c; ")
    ;;        (emacs-uptime "Uptime:%hh"))))

    ; buffer name field
    '(:eval
      (let*
          ((mface  (if (window-has-focus)
                              'mode-line-buffer-name-face
                            'mode-line-buffer-name-inactive-face)))
        (propertize " %b " 'face mface)))

    ; buffer position field
    (mode-line-str-dflt " %p (%l,%c) ")

    ; major mode field
    (mode-line-buffer-name-entry " %m " buffer-file-coding-system)

    (mode-line-str-dflt " ")

    ;;; MODE SPECIFIC AREAS

    ; text mode: Show word, letter, char count
    '(:eval (when (eq major-mode 'text-mode)
             (mode-line-str-dflt
              (if transient-mark-mode
               (line-word-char-count (point) (mark))
               (line-word-char-count)))))

    ;;; STATUSES: less important stuff
    (mode-line-status-entry (and (window-has-focus) (fboundp 'eyebrowse--get))     (format " W:%d " (eyebrowse--get 'current-slot)) "Current Workspace")
    (mode-line-status-entry (/= text-scale-mode-amount 0) (format " Â±%d " text-scale-mode-amount) "Font scale")
    (mode-line-status-entry buffer-read-only              " RO "                                  "Buffer is read-only")
    (mode-line-status-entry vc-mode                       (concat " VC:" vc-mode " ")             vc-mode)
    (mode-line-status-entry isearch-mode                  (concat " search: " isearch-string " ") "isearch in progress")

    ;;; NOTIFICATIONS: IMPORTANT STUFF
    (mode-line-notification-entry (and (buffer-modified-p) (buffer-file-name)) " !! "   "Buffer has been modified")
    (mode-line-notification-entry (buffer-narrowed-p)                          " >< "   "Buffer is narrowed")

    ;; '(:eval (debug-window-focus))
    ;; '(:eval mode-line-frame-identification)

    (mode-line-str-dflt
     (let*
         ((gap (if (window-has-focus)
                 8
                 0)))
       (mode-line-fill mface gap)))

    '(:eval
     (when (window-has-focus)
       (mode-line-buffer-name-entry (format-time-string " %I:%M%p ") "")))))

#+END_SRC

** Phrase Highlight

This highlights all occurrences of the thing at point, automatically.

#+BEGIN_SRC emacs-lisp
(add-hook 'pre-command-hook 'clear-phrase-highlight)
(defvar-local hlight-region-face-var nil)
(defvar-local hlight-regex nil)
(defvar-local hlight-region-type nil)
(defvar-local hlight-region-active nil)
(defvar-local region-occurrence-highlight-mode nil)
(defvar-local region-occurrence-highlight-at-point t)
(setq-default region-occurrence-highlight-at-point t)

(defun clear-phrase-highlight ()
  "Remove region phrase highlight"
  (if hlight-region-active
      (progn
        (unhighlight-regexp (hi-lock-process-phrase hlight-regex))
        (setq hlight-region-active nil)
        (font-lock-fontify-buffer))))

(defun update-phrase-highlight ()
  "Highlight region if active"
  (clear-phrase-highlight)
  (if (and region-occurrence-highlight-mode (not isearch-mode) (not (minibufferp)))
      (progn
        (setq hlight-regex nil)
        (if mark-active
            (setq
             hlight-regex           (buffer-substring-no-properties (region-beginning) (region-end))
             hlight-region-face-var 'region-occurrence-highlight-face
             hlight-region-type     'region)
          (let
              ((sym (thing-at-point 'symbol)))
            (if (and region-occurrence-highlight-at-point sym (> (length sym) 0))
                (setq hlight-regex           (concat "\\_<" (hi-lock-process-phrase (strip-text-properties (thing-at-point 'symbol))) "\\_>")
                      hlight-region-face-var 'region-occurrence-no-region-highlight-face
                      hlight-region-type     'at-pt))))
        (if hlight-regex
            (progn
              ;; (message (format "Occurrences of %s" hlight-regex))
              (highlight-phrase (hi-lock-process-phrase hlight-regex) hlight-region-face-var)
              (setq hlight-region-active t)
              (font-lock-fontify-buffer))))))

(run-with-idle-timer 0.25 t 'update-phrase-highlight)
#+END_SRC

* File Associations

** Quick Mappings
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.plt\\'" . gnuplot-mode))
(add-to-list 'auto-mode-alist '("\\.m$"     . octave-mode ))
#+END_SRC

** Generic Modes

B2C, T2C, and F2C files

#+BEGIN_SRC emacs-lisp
(define-generic-mode 
  '2c-mode                       ; name of the mode to create
  '("*")                         ; comments start with '!!'
  '("c_dep")                     ; keywords
  nil                            ; special words
  ;; '(("=" . 'font-lock-operator)     ;; '=' is an operator
  ;; (";" . 'font-lock-builtin))     ;; ';' is a built-in 
  '("\\.t2c\\'"  "\\.b2c\\'" "\\.f2c\\'")    ; files for which to activate this mode 
  '((lambda () (run-hooks 'prog-mode-hook)))                            ; other functions to call
  "A mode for B2C, T2C, & F2C files")   ; doc string for this mode
#+END_SRC

Monkey-C Mode

#+BEGIN_SRC emacs-lisp
(define-generic-mode
  'monkey-c-mode
  '("//")
  '("using" "as" "class" "extends" "function" "hidden" "return")
  '("initialize" "onUpdate")
  '("\\.mc\\'")
  '((lambda () (run-hooks 'prog-mode-hook)))
  "A mode for Monkey-C")
#+END_SRC

* Mode Management

Handle which modes/settings are triggered where.

** Global Default Modes

Truncate lines, don't wrap.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

Don't use lockfiles....SeaFile shits the bed.

#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

Manage workspaces

#+BEGIN_SRC emacs-lisp
(eyebrowse-mode t)
#+END_SRC

Persist workspaces, etc.

TODO: this actually causes me many problems

#+BEGIN_SRC
(desktop-save-mode 1)
#+END_SRC

Help me with my keys

#+BEGIN_SRC emacs-lisp
(which-key-mode)
#+END_SRC


Enable helm by default

#+BEGIN_SRC emacs-lisp
(helm-mode)
#+END_SRC

Enable shackle window rules

#+BEGIN_SRC emacs-lisp
(shackle-mode)
#+END_SRC

Hide the toolbar, menu bar, and scroll bars.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode   -1)
(menu-bar-mode    0)
(scroll-bar-mode -1)
#+END_SRC

Open the speedbar

TODO: Need to tweak this more before I want it enabled...

#+BEGIN_SRC emacs-lisp
;; (sr-speedbar-open)
#+END_SRC

Highlight and jump through instances of whatever is at point.

#+BEGIN_SRC emacs-lisp
(setq region-occurrence-highlight-mode t)
#+END_SRC

Use yasnippet everywhere.

#+BEGIN_SRC emacs-lisp
(yas-global-mode t)
#+END_SRC

Use ido by default.

#+BEGIN_SRC emacs-lisp
(ido-mode)
#+END_SRC

** Mode Triggers
*** prog-mode

The hook =prog-mode-hook= is triggered in all programming major-modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
  '(lambda ()
    (flyspell-prog-mode) ;; Spelling corrections in comments
    (linum-mode))       ;; Needed to catch compiler errors when compiling outside of emacs
    (setq region-occurrence-highlight-mode t))
#+END_SRC

*** text-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
  (lambda ()
    (flyspell-mode)
    (visual-line-mode)
    (variable-pitch-mode t)
    (text-scale-increase 1)))
#+END_SRC

*** org-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
  (lambda ()
    (visual-line-mode nil)
    (setq truncate-lines t)
    (variable-pitch-mode nil)
    (org-autolist-mode)
    (text-scale-increase 0)))
#+END_SRC

*** c-mode

Use employer's preferred C format...

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
  '(lambda ()
     (set 'c-basic-offset  4)            ; 4 spaces for indentation
     (set 'c-electric-flag nil)          ; don't fuck with my indentation as I type
     (c-set-style "whitesmith")
     (setq comment-start "// ")
     (setq comment-end   "")))
#+END_SRC

*** octave-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'octave-mode-hook
  (lambda ()
    (local-set-key (kbd "C-\\") 'octave-send-region-or-line)))
#+END_SRC
*** compilation-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'compilation-mode-hook
  (lambda ()
    (visual-line-mode)
    (local-set-key (kbd "H-]") 'next-error)
    (local-set-key (kbd "H-[") 'previous-error)))
#+END_SRC
*** shell-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook
  (lambda ()
    (setq show-trailing-whitespace nil)
    (visual-line-mode t)))
#+END_SRC
*** python-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>")         'generic-smart-tab-key)
    (local-set-key (kbd "TAB")           'generic-smart-tab-key)
    (local-set-key (kbd "C-t")           'indent-for-tab-command)
    (local-set-key (kbd "<backspace>")   'backward-delete-char-untabify)
    (local-set-key (kbd "C-\\")          'run-python-in-shell)
    (local-set-key (kbd "C-r")           'align-current)
    (local-set-key (kbd "C-|")           'python-shell-send-buffer)))
#+END_SRC
*** ruby-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'ruby-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t") 'indent-for-tab-command)))
#+END_SRC

*** scheme-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'scheme-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t")   'indent-for-tab-command)))
#+END_SRC

*** emacs-lisp-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
  (lambda ()
    (local-set-key (kbd "<tab>") 'generic-smart-tab-key)
    (local-set-key (kbd "TAB")   'generic-smart-tab-key)
    (local-set-key (kbd "C-t")   'indent-for-tab-command)))
#+END_SRC

*** term-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'term-mode-hook
  (lambda ()
    (linum-mode -1)
    (setq show-trailing-whitespace nil)
    (term-pager-toggle)))
#+END_SRC
* Package Configurations
** org-mode

Set the base location for my org tree.

#+BEGIN_SRC emacs-lisp
(setq my-org-file-tree-base-path "/encrypted_data/org")
#+END_SRC

Load the tree's initialization code.

#+BEGIN_SRC emacs-lisp
(if load-org
  (org-babel-load-file (concat my-org-file-tree-base-path "/init.org")))
#+END_SRC

** sr-speedbar

Don't automatically change directory on me!

TODO: See speedbar enable above

#+BEGIN_SRC emacs-lisp
;;(sr-speedbar-refresh-turn-off)
;;(setq speedbar-use-images nil) ;; I'd actually like better looking images..
#+END_SRC

* Monkey Patching

** isearch Advice

This advice modifies isearch such that it will always auto-wrap whenever a match is not found between point and the end of the buffer.

#+BEGIN_SRC emacs-lisp
(defadvice isearch-search (after isearch-no-fail activate)
  "Autowrap searches."
  (unless isearch-success
    (ad-disable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)
    (isearch-repeat (if isearch-forward 'forward))
    (ad-enable-advice 'isearch-search 'after 'isearch-no-fail)
    (ad-activate 'isearch-search)))
#+END_SRC

This advice causes isearch, the split-window-*, compilation mode, etc, functions to recenter the buffer. This means less time spent searching for the cursor, without having a distracting cursor design.

#+BEGIN_SRC emacs-lisp
 (defadvice isearch-forward
    (after isearch-forward-recenter activate)
    (recenter))

(defadvice isearch-repeat-forward
  (after isearch-repeat-forward-recenter activate)
  (recenter))

(defadvice isearch-repeat-backward
  (after isearch-repeat-backward-recenter activate)
  (recenter))

(defadvice isearch-printing-char
  (after isearch-printing-char-then-recenter activate)
  (recenter))

(defadvice split-window-below
  (after split-window-below-recenter activate)
  (recenter))

(defadvice split-window-left
  (after split-window-left-recenter activate)
  (recenter))

(defadvice split-window-right
  (after split-window-right-recenter activate)
  (recenter))

(defadvice split-window-above
  (after split-window-above-recenter activate)
  (recenter))

(defadvice compile-goto-error
  (after compile-goto-error-then-recenter activate)
  (recenter))
#+END_SRC
** diff-hl Triggers

Whenever a file in version control is opened, enable diff-hl mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook
  (lambda ()
    (when (vc-backend (buffer-file-name))
        (diff-hl-mode)
        (diff-hl-update))))
#+END_SRC
** find-file

Yes, I do want to create the directories....

#+BEGIN_SRC emacs-lisp
(defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
  "Create parent directory if not exists while visiting file."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir)))))
#+END_SRC
* OS Integration

Sometimes, I want emacs to be my window manager.

** EXWM

Use emacs as window manager. :)

#+BEGIN_SRC emacs-lisp
(defun my:launch-de()
    (package-require 'exwm)
    (package-require 'exwm-systemtray)
    (package-require 'exwm-edit)
    (package-require 'clipmon)
    (clipmon-mode-start)
    (exwm-enable)
    (defun exwm-rename-buffer ()
      (interactive)
      (exwm-workspace-rename-buffer
       (concat exwm-class-name ":"
               (if (<= (length exwm-title) 50) exwm-title
                 (concat (substring exwm-title 0 49) "...")))))

    ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
    (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
    (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
    (setq window-divider-default-right-width 4)
    (window-divider-mode t)
    (exwm-systemtray-enable))
    ;(setq exwm-manage-configurations '((t char-mode t))))
#+END_SRC

#+RESULTS:
: my:launch-de

* Window Placement

Place helm completions in a temp window at the bottom of the frame, period. Thankfully, ivy doesn't need this.

#+BEGIN_SRC emacs-lisp
(setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.4)))
#+END_SRC

* Key Mappings
Most of my custom key-bindings use the hyper key. The goal here is to prevent any reasonable possibility of collision between personal keybindings and package keybindings. By convention, C-<key> is already reserved for the user, but we have another modifier available anyway, so why not use it? In my case, the hyper modifier is bound to caps lock.

To map caps lock to hyper under Xorg, you may do the following:

#+BEGIN_SRC bash
clear mod4
keycode 66 = Hyper_L
add mod4 = Super_L Super_R
clear lock
add mod3 = Hyper_L
#+END_SRC

In windows, install AutoHotkey, and place the following in a startup script...

#+BEGIN_SRC autohotkey
SetTitleMatchMode, 2
IfWinActive, emacs
{
    CapsLock::AppsKey
    return
}
#+END_SRC

...with the following elisp...

#+BEGIN_SRC emacs-lisp
(if (equal system-type 'windows-nt)
  (setq w32-pass-lwindow-to-system nil
        w32-pass-rwindow-to-system nil
        w32-pass-apps-to-system nil
        w32-lwindow-modifier 'super
        w32-rwindow-modifier 'super
        w32-apps-modifier 'hyper))
#+END_SRC

Do note that this leaves the apps key unusable in emacs, except as a secondary hyper modifier. I have not yet found another way to do this which works well for me.

** Functions

Functions designed specifically to be used as key mappings.

*** C stuff

#+BEGIN_SRC emacs-lisp
(defun c-smart-tab-key ()
  "Indent when at left margin or right of whitespace, autocomplete elsewhere"
  (interactive)
  (smart-tab-key 'c-indent-line-or-region 'dabbrev-expand c-basic-offset))

(defun c-insert-debugging-printf ()
  "Insert a debugging tag in C."
  (interactive)
  (insert "printf(\"%50s:%d.\\n\", __FILE__, __LINE__ ); // TODO BJG: DEBUG!")
  (left-char 64))

(defun c-insert-todo-comment ()
  "Insert a todo tag (C-compliant)."
  (interactive)
  (insert " /* TODO BJG:  */ ")
  (left-char 4))

(defun c-insert-function-skeleton (name desc ret-type)
  "Insert the skeleton for a new function."
  (interactive "sFunction Name: \nsDescription: \nsReturn Type: ")
  (insert "/*********************************************************************\n")
  (insert "*\n")
  (insert "*   PROCEDURE NAME:\n")
  (insert "*       ")
  (insert name)
  (insert "\n*\n")
  (insert "*   DESCRIPTION:\n")
  (insert "*       ")
  (insert desc)
  (insert "\n*\n")
  (insert "*********************************************************************/\n")
  (insert ret-type)
  (insert " ")
  (insert name)
  (insert "\n")
  (insert-c-basic-offset-spaces)
  (insert "(\n")
  (insert-c-basic-offset-spaces)
  (insert "\n")
  (insert-c-basic-offset-spaces)
  (insert ")\n")
  (insert "{\n\n} ")
  (insert "/* ")
  (insert name)
  (insert "() */")
  (left-char ( + 20 (length name))))

(defun c-insert-region-heading ()
  "Insert a region heading (variables, initializations, etc)."
  (interactive "")
  (insert "/*----------------------------------------------------------\n")
  (indent-for-tab-command)
  (insert "\n")
  (indent-for-tab-command)
  (insert "----------------------------------------------------------*/")
  (indent-for-tab-command)
  (beginning-of-line)
  (delete-char 2)
  (previous-line)
  (end-of-line)
  (backward-delete-char 2))

(defun c-insert-forced-todo ()
  ""
  (interactive)
  (insert "#error \"You forgot to come back to this, so you're not allowed to compile.\""))

(defun c-insert-if-block ()
  ""
  (interactive)
  (insert "if(  )")
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "}")
  (previous-line 3)
  (end-of-line)
  (left-char 2))

(defun c-insert-while-block ()
  ""
  (interactive)
  (insert "while(  )")
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "}")
  (previous-line 3)
  (end-of-line)
  (left-char 2))

(defun c-insert-for-block (var-name start-val end-val)
  ""
  (interactive "sIterator: \nsStart Val (inclusive): \nsEnd Val (Exclusive): ")
  (interactive)
  (insert (format "for( %s = %s; %s < %s; %s++ )" var-name start-val var-name end-val var-name))
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "}")
  (previous-line 1)
  (end-of-line)
  (indent-for-tab-command))

(defun c-insert-do-while-block ()
  ""
  (interactive)
  (insert "do")
  (newline-and-indent)
  (insert "{")
  (newline-and-indent)
  (newline-and-indent)
  (insert "} while(  );")
  (previous-line 1)
  (c-indent-line-or-region)
  (end-of-line))

(defun c-insert-preproc-if ()
  ""
  (interactive)
  (insert "#if(  )")
  (newline)
  (c-indent-line-or-region)
  (newline)
  (c-indent-line-or-region)
  (insert "#endif")
  (previous-line 2)
  (c-indent-line-or-region)
  (end-of-line)
  (left-char 2))
#+END_SRC

*** Org stuff

#+BEGIN_SRC emacs-lisp
(defun my:org-journal-open-today()
  "Open today's journal file."
  (interactive)
  (find-file (my-org-journal-current-day-path)))

(defun my:org-concept-open ()
  (interactive)
  (find-file (my-org-find-concept)))
#+END_SRC

*** Window stuff.

Defined to balance existing function names.

#+BEGIN_SRC emacs-lisp
(defun split-window-above ()
  "Split current window into top and bottom, with focus left in bottom."
  (interactive)
  (split-window-below)
  (windmove-down))

(defun split-window-left ()
  "Split current window into left and right, with focus left in right."
  (interactive)
  (split-window-right)
  (windmove-right))

(defun my:set-window-opacity (percent)
  "Set window opacity. Prefix arg is level. arg 1 is special and means
   opaque because my elisp sucks."
  (interactive "p")
  (opacity (if (eq percent 1) 100 percent)))
#+END_SRC

#+RESULTS:
: my:set-window-opacity

*** Text stuff

#+BEGIN_SRC emacs-lisp
(defun smart-beginning-of-line ()
  "Move point to first non-whitespace character or beginning-of-line.
   Move point to the first non-whitespace character on this line.
   If point was already at that position, move point to beginning of line."
  (interactive) ; Use (interactive "^") in Emacs 23 to make shift-select work
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
         (beginning-of-line))))

(defun smart-copy-paste ()
  "Smart copy or paste"
  (interactive)
  (if (use-region-p)
      (if (and (boundp 'rectangle-mark-mode) rectangle-mark-mode)
          (copy-rectangle-as-kill (region-beginning) (region-end))
        (kill-ring-save (region-beginning) (region-end)))
    (yank)))

(defun smart-set-mark ()
  "Consecutive calls expand region. First sets mark."
  (interactive)
  (if mark-active
    (call-interactively 'er/expand-region)
  (call-interactively 'set-mark-command)))

(defun smart-cut-or-delete ()
  "If region, cut, else, delete char"
  (interactive)
  (if (use-region-p)
    (kill-region (region-beginning) (region-end))
    (delete-forward-char 1)))

(defun whack-whitespace-after-point (arg)
  ;; https://www.emacswiki.org/emacs/DeletingWhitespace
  "Delete all white space from point to the next word.  With prefix ARG
  delete across newlines as well.  The only danger in this is that you
  don't have to actually be at the end of a word to make it work.  It
  skips over to the next whitespace and then whacks it all to the next
  word."
  ;; (interactive "P")
    (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
      (re-search-forward regexp nil t)
      (replace-match "" nil nil)))

(defun smart-batch-delete ()
  (interactive)
  (if (or (looking-at "$") (looking-at " "))
      (whack-whitespace-after-point t)
    (kill-word nil)))

(defun my:comment-region-or-line ()
  "If region active, comment it. Else, comment current line."
  (interactive)
  (call-interactively (if (use-region-p)
        'comment-region
      'comment-line)))

(defun newline-after-current ()
  "Skip to end of this line, insert a new one, autoindent, recenter cursor."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent)
  (scroll-up 1))

(defun newline-before-current ()
  "Move this line down, go to beginning of a new line where this one was."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (move-beginning-of-line nil)
  (when (looking-at "[ \t]+$")
    (kill-line)
    (setq kill-ring (cdr kill-ring))
    (insert "\n")
    (forward-line -1))
  (forward-line -1)
  (indent-for-tab-command))

(defun newline-before-and-after-current()
  "Insert new lines above and below current line."
  (interactive)
  (newline-after-current)
  (newline-before-current))

(defun previous-appropriate-buffer-if-hidden ()
  (when (or
         (and (hidden-buffer-p) (not (dumping-window-p)))
         (and (not (hidden-buffer-p)) (dumping-window-p)))
    (previous-appropriate-buffer)))

(defun hidden-buffer-p ()
  (or
   (string-match "\*.*\*" (buffer-name))      ; *buffer*s
   (string-match "^COM[0-9]*$" (buffer-name)) ; windows serial buffer
   (string-match "^/dev/tty*" (buffer-name))  ; *nix serial buffer
   (string-match "^TAGS$" (buffer-name))))    ; TAGS file

(defun next-non-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-non-sys-buffer-with-basecase 'next-buffer start-buffer)))

(defun previous-non-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-non-sys-buffer-with-basecase 'previous-buffer start-buffer)))

(defun next-non-sys-buffer-with-basecase (advance-f base)
  (funcall advance-f)
  (if (and
       (not (eq base (buffer-name)))
       (hidden-buffer-p))
      (next-non-sys-buffer-with-basecase advance-f base)))

(defun next-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-sys-buffer-with-basecase 'next-buffer start-buffer)))

(defun previous-sys-buffer ()
  ""
  (interactive)
  (let
      ((start-buffer (buffer-name)))
    (next-sys-buffer-with-basecase 'previous-buffer start-buffer)))

(defun next-sys-buffer-with-basecase (advance-f base)
  (funcall advance-f)
  (if (and
       (not (eq base (buffer-name)))
       (not( hidden-buffer-p)))
      (next-sys-buffer-with-basecase advance-f base)))

(defun next-appropriate-buffer ()
  (interactive)
  ; (message (apply 'concat (mapcar (lambda (x) (format "%s -- " x)) (buffer-list))))
  (if (dumping-window-p)
      (next-sys-buffer)
    (next-non-sys-buffer)))

(defun previous-appropriate-buffer ()
  (interactive)
  (if (dumping-window-p)
      (previous-sys-buffer)
    (previous-non-sys-buffer)))
#+END_SRC

Dormant ideas

#+BEGIN_SRC
(defun smart-tab-key (indent autocomplete indent-count)
"Indent when at left margin or right of whitespace, autocomplete elsewhere."
  (cond (( or (eq last-command 'yank) (eq last-command 'yank-pop)) (yank-pop))
        (( or
           (eq last-command 'find-tag)
           (eq last-command 'find-tag-other-window)
           (eq last-command 'find-tag-wrapped)
           (eq last-command 'find-tag-wrapped-new-window))
         (progn
           (let ((current-prefix-arg '(4)))
             (message "Finding next possible definition...")
             (call-interactively 'find-tag))
           (recenter-top-bottom)
           (setq this-command 'find-tag)))
        ((use-region-p) (indent-rigidly (region-beginning) (region-end) indent-count))
        ((or (= 0 (current-column)) (= ?\s (char-before))) (funcall indent))
        (t (funcall autocomplete))))

(defun generic-smart-tab-key ()
  "Indent when at left margin or right of whitespace, autocomplete elsewhere"
  (interactive)
  (smart-tab-key 'indent-for-tab-command 'ac-fuzzy-complete 1))
#+END_SRC

*** Other stuff

#+BEGIN_SRC emacs-lisp
(defun my:goto-previous-change ()
  (interactive)
  (diff-hl-previous-hunk)
  (recenter))

(defun my:goto-next-change ()
  (interactive)
  (diff-hl-next-hunk)
  (recenter))

(defun my:goto-line ()
  (interactive)
  (call-interactively 'goto-line)
  (recenter))

(defun my:annotated-bookmark ()
  (interactive)
  (let* ((bm-annotate-on-create t)) (bm-toggle)))

(defun my:scroll-up-some-lines ()
  (interactive)
  (scroll-up 15))

(defun my:scroll-down-some-lines ()
  (interactive)
  (scroll-down 15))

(defun my:scroll-left-some-lines ()
  (interactive)
  ;; invert axis
  (scroll-right 5))

(defun my:scroll-right-some-lines ()
  (interactive)
  ;; invert axis
  (scroll-left 5))

(defun my:run-or-save-macro (name)
  (if defining-kbd-macro
      (progn
        (kmacro-end-or-call-macro nil)
        (fset
         (intern (format "mcr-%s" name))
         last-kbd-macro))
    (execute-kbd-macro
     (intern
      (format "mcr-%s" name)))))

(defun my:run-macro (name)
  (execute-kbd-macro
     (intern
      (format "mcr-%s" name))))

(defun execute-command-toggle (prefixes)
  "If region active, clear it. Else, toggle the M-x menu."
  (interactive "P")
  (cond
    ((window-minibuffer-p)                    (m-keyboard-escape-quit))
    (mark-active                              (progn (setq mark-active nil) (run-hooks 'deactivate-mark-hook)))
    (t                                        (counsel-M-x prefixes))))

(defun execute-command-toggle-ignore-region (prefixes)
  "Toggle M-x menu."
  (interactive "P")
  (if (window-minibuffer-p)
      (m-keyboard-escape-quit)
    (counsel-M-x prefixes)))
#+END_SRC

#+RESULTS:
: execute-command-toggle-ignore-region

** Aliases

Alias some basic functionality to different that may have different backends during experimentation.

#+BEGIN_SRC emacs-lisp
(defalias 'my:google         'helm-google-suggest)
(defalias 'my:find-text      'swiper)
(defalias 'my:find-this-text 'swiper-thing-at-point)
(defalias 'my:find-buffer    'helm-mini)
(defalias 'my:run-program    'helm-run-external-command)
(defalias 'my:find-file      'helm-find-files)
(defalias 'my:occur          'helm-occur)
#+END_SRC

** Keys

#+BEGIN_SRC emacs-lisp

(general-auto-unbind-keys)

(setq my:shortcut-leader "<f12>")
(general-define-key :prefix my:shortcut-leader

    ;; Double tap
    my:shortcut-leader 'org-capture

    ;; "o"-> Org global shortcuts
    "od"               'my:org-journal-open-today
    "oa"               'org-agenda
    "ot"               'org-todo-list
    "oc"               'my:org-concept-open

    ;; "m"-> Magit global shortcuts
    "ms"               'magit-status
    "mb"               'magit-blame
    "md"               'magit-diff

    ;; language modes
    "lm"               'markdown-mode
    "lp"               'python-mode
    "le"               'emacs-lisp-mode
    "lc"               'c-mode
    "lo"               'org-mode

    ;; external tools
    "g"                'my:google
    "x"                'my:run-program)

(general-define-key

    ;; Controlling emacs
    "M-x"        'counsel-M-x
    "<escape>"   'execute-command-toggle
    "S-<escape>" 'execute-command-toggle-ignore-region

    ;; Window navigation
    "H-<right>" 'windmove-right
    "H-<left>"  'windmove-left
    "H-<down>"  'windmove-down
    "H-<up>"    'windmove-up
    "<S-f8>"    'delete-window-ex
    "<H-f8>"    'kill-current-buffer
    "<f8>"      'delete-window-ex

    ;; Workspaces (virtual desktops/saved window configs/etc)
    "H-0"       'eyebrowse-switch-to-window-config-0
    "H-1"       'eyebrowse-switch-to-window-config-1
    "H-2"       'eyebrowse-switch-to-window-config-2
    "H-3"       'eyebrowse-switch-to-window-config-3
    "H-4"       'eyebrowse-switch-to-window-config-4
    "H-5"       'eyebrowse-switch-to-window-config-5
    "H-6"       'eyebrowse-switch-to-window-config-6
    "H-7"       'eyebrowse-switch-to-window-config-7
    "H-8"       'eyebrowse-switch-to-window-config-8
    "H-9"       'eyebrowse-switch-to-window-config-9

    ;; Window splitting
    ; names seem wrong, but I imagine dpad right to mean "send focus right", etc.
    "H-s <left>"  'split-window-right
    "H-s <right>" 'split-window-left
    "H-s <down>"  'split-window-above
    "H-s <up>"    'split-window-below

    ; Window resizing
    "H-S-<up>"      'enlarge-window
    "H-S-<right>"   'enlarge-window-horizontally
    "H-S-<down>"    'shrink-window
    "H-S-<left>"    'shrink-window-horizontally

    ;; Frame manipulations
    "<H-f11>"   'toggle-frame-fullscreen
    "H-t"       'my:set-window-opacity

    ;; Keyboard macros
    "H-*"        'kmacro-start-macro
    "<f1>"       (lambda () (interactive) (my:run-or-save-macro "f1"))
    "<f2>"       (lambda () (interactive) (my:run-or-save-macro "f2"))
    "<f3>"       (lambda () (interactive) (my:run-or-save-macro "f3"))
    "<f4>"       (lambda () (interactive) (my:run-or-save-macro "f4"))
    "C-<f1>"     (lambda () (interactive) (my:run-macro "f1"))
    "C-<f2>"     (lambda () (interactive) (my:run-macro "f2"))
    "C-<f3>"     (lambda () (interactive) (my:run-macro "f3"))
    "C-<f4>"     (lambda () (interactive) (my:run-macro "f4"))

    ;; File operations
    "<f5>"   'my:find-file
    "<f6>"   'custom-save-buffer
    "<f7>"   'write-file

    ;; OS Utilities
    "H-f"  'rgrep
    "<f9>" 'shell

    ;; Text navigation
    "<home>"   'smart-beginning-of-line
    "M-<up>"   'backward-paragraph
    "M-<down>" 'forward-paragraph
    "H-o"      'my:occur
    "H-a"      'my:find-text
    "H-A"      'my:find-this-text
    "H-["      'my:goto-previous-change
    "H-]"      'my:goto-next-change
    "H-g"      'my:goto-line
    "H-p"      'isearch-forward-regexp
    "H-k"      'next-line
    "H-i"      'previous-line
    "H-j"      'left-char
    "H-l"      'right-char
    "H-h"      'smart-beginning-of-line

    ;; Text selection and editing
    "C-<delete>"   'smart-batch-delete
    "<insert>"     'smart-copy-paste
    "<delete>"     'smart-cut-or-delete
    "C-SPC"        'smart-set-mark
    "H-r"          'anzu-query-replace-regexp
    "H-y"          'yas-insert-snippet
    "C-<return>"   'newline-after-current
    "M-<return>"   'newline-before-current
    "C-M-<return>" 'newline-before-and-after-current
    "C-t"          'indent-according-to-mode
    "C-z"          'undo-tree-undo
    "C-S-z"        'undo-tree-redo
    "H-z"          'undo-tree-visualize
    "C-c a"        'mark-whole-buffer

    ;; Bookmarks
    "H-SPC"                   'bm-toggle
    "H-S-SPC"                 'my:annotated-bookmark
    "H-}"                     'bm-next
    "H-{"                     'bm-previous
    "<left-margin> <mouse-1>" 'bm-toggle-mouse

    ;; Text display transformations
    "H-h" 'origami-toggle-node

    ;; Buffer navigation
    "H-b"         'my:find-buffer
    "<prior>"     'previous-appropriate-buffer
    "<next>"      'next-appropriate-buffer
    "C-H-<left>"  'buf-move-left
    "C-H-<right>" 'buf-move-right
    "C-H-<up>"    'buf-move-up
    "C-H-<down>"  'buf-move-down
    "C-<up>"      'my:scroll-down-some-lines
    "C-<down>"    'my:scroll-up-some-lines
    "C-<left>"    'my:scroll-left-some-lines
    "C-<right>"   'my:scroll-right-some-lines
    "H-u"         'line-to-top-of-window

    ;; Other
    "H-=" '(lambda () (interactive) (text-scale-increase 1))
    "H--" '(lambda () (interactive) (text-scale-decrease 1)))

(general-define-key :keymaps 'isearch-mode-map
    "<backspace>" 'isearch-del-char
    "<escape>"    'isearch-exit
    "<C-escape>"  'isearch-abort
    "<return>"    'isearch-repeat-forward
    "S-<return>"  'isearch-repeat-backward
    "<right>"     'isearch-yank-word-or-char
    "<left>"      'isearch-del-char
    "<down>"      'isearch-repeat-forward
    "<up>"        'isearch-repeat-backward)

(general-define-key :keymaps 'query-replace-map
    "<up>"     'backup
    "<down>"   'skip
    "<escape>" 'exit
    "<return>" 'act
    "<insert>" 'edit)

(general-define-key :keymaps 'c-mode-map
    "<tab>" 'c-smart-tab-key
    "TAB"   'c-smart-tab-key
    "C-t"   'c-indent-line-or-region
    "C-r"   'align-current)

(general-define-key :keymaps 'c-mode-map :prefix "H-c"
    "1" 'c-insert-region-heading
    "2" 'c-insert-function-skeleton
    "3" 'c-insert-forced-todo
    "4" 'c-insert-debugging-printf
    "5" 'c-insert-ternary-for-boolean-to-string
    "6" 'c-insert-todo-comment
    "f" 'c-insert-if-block
    "o" 'c-insert-for-block
    "w" 'c-insert-while-block
    "d" 'c-insert-do-while-block
    "F" 'c-insert-preproc-if-block
    "D" 'c-insert-preproc-ifdef-block
    "N" 'c-insert-preproc-ifndef-block
    "I" 'c-insert-preproc-include-block)

(general-define-key :keymaps 'prog-mode-map
    "H-;" 'my:comment-region-or-line)

(general-define-key :keymaps 'shell-mode-map
    "C-p"   'comint-previous-input
    "C-n"   'comint-next-input
    "C-M-l" nil)

(general-define-key :keymaps 'flyspell-mode-map
    "H-c" 'flyspell-auto-correct-word)

(customize-set-variable 'exwm-input-global-keys
    `((,(kbd "H-<left>") .    windmove-left)
      (,(kbd "H-s <up>") .    split-window-below)
      (,(kbd "H-<right>") .   windmove-right)
      (,(kbd "H-<down>") .    windmove-down)
      (,(kbd "H-<up>") .      windmove-up)
      (,(kbd "<H-f8>") .      kill-current-buffer)
      (,(kbd "S-<F8>") .      delete-window-ex)
      (,(kbd "S-<F8>") .      delete-window-ex)
      (,(kbd "H-b") .         my:find-buffer)
      (,(kbd "H-S-<up>") .    (lambda () (interactive) (enlarge-window 5)))
      (,(kbd "H-S-<right>") . enlarge-window-horizontally)
      (,(kbd "H-S-<down>") .  (lambda () (interactive) (shrink-window 5)))
      (,(kbd "H-S-<left>") .  shrink-window-horizontally)
      (,(kbd "H-s <down>") .  split-window-above)
      (,(kbd "H-s <left>") .  split-window-right)
      (,(kbd "H-s <right>") . split-window-left)
      (,(kbd "H-c") .         exwm-input-release-keyboard)
      (,(kbd "H-l") .         exwm-input-grab-keyboard)
      (,(kbd "H-e") .         exwm-edit--compose)
      (,(kbd "H-0") .         eyebrowse-switch-to-window-config-0)
      (,(kbd "H-1") .         eyebrowse-switch-to-window-config-1)
      (,(kbd "H-2") .         eyebrowse-switch-to-window-config-2)
      (,(kbd "H-3") .         eyebrowse-switch-to-window-config-3)
      (,(kbd "H-4") .         eyebrowse-switch-to-window-config-4)
      (,(kbd "H-5") .         eyebrowse-switch-to-window-config-5)
      (,(kbd "H-6") .         eyebrowse-switch-to-window-config-6)
      (,(kbd "H-7") .         eyebrowse-switch-to-window-config-7)
      (,(kbd "H-8") .         eyebrowse-switch-to-window-config-8)
      (,(kbd "H-9") .         eyebrowse-switch-to-window-config-9)
      (,(kbd "C-M-<left>") .  eyebrowse-prev-window-config)
      (,(kbd "C-M-<right>") . eyebrowse-next-window-config)))

(customize-set-variable 'exwm-input-simulation-keys
    `((,(kbd "H-a") .        ,(kbd "C-f"))
      (,(kbd "<insert>") .   ,(kbd "C-c"))
      (,(kbd "S-<insert>") . ,(kbd "C-v"))))
#+END_SRC

#+RESULTS:
: (([16777313] . ) ([insert] . ) ([S-insert] . ))

Dead block -- can be used to generate keys for workspace switching.
I'm just using window layouts instead.

#+BEGIN_SRC
,@(mapcar (lambda (i)
        `(,(kbd (format "H-%d" i)) .
          (lambda ()
              (interactive)
              (exwm-workspace-switch-create ,i))))
              (number-sequence 0 9)))
#+END_SRC

* To Be Completed

** Switch to general
https://github.com/noctuid/general.el

** Better workspace management
Workspaces..or company mode, or whatever that is?
https://github.com/wasamasa/eyebrowse

** Less RSI?
Evil?
https://github.com/chrisdone/god-mode

** Switch to require-package
** Clean up some bindings with hydra
** Get CEDET set up
*** or at least tags (etags? rtags?)
*** compilation-mode
*** magit
** A code folding package
** key cheatsheet printer
